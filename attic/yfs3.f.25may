      SUBROUTINE expand(mode,xpar,npar)
*     ****************************************
*=======================================================================
*=======================================================================
*=============================YFS3======================================
*=====================FERMION PAIR PRODUCTION===========================
*===============INITIAL AND FINAL STATE EXPONENTIATION==================
*=======================================================================
*=======================================================================
*=======================YFS VERSION 3.4.0===============================
*=======================================================================
*=========================FEBRUARY  1993================================
*=========================     MAY  1997================================
*=======================================================================
* AUTHORS:
*    S. Jadach, Institute of Nuclear Physics, Cracow, Poland
*    B.F.L. Ward, University of Tennessee, Knoxville, Tennessee
*=======================================================================
*
* some controll histograming still in PROGRAM
*
* generator of YENNIE-FRAUTSCHI-SUURA type
* with exponentiated single bremsstrahlung
********** input
* mode =-1/0/1/2 defines
*       initialization/generation/give-xsection/final-report
* cmsene   = centre of mass energy (gev)
* npar(1)=keyrad=1000001 initial state only
*         keyrad=1000010 final state only
*         keyrad=1000011 initial + final state
*         keyrad=1000000 born without any bremss.
*         keyrad=100n001 fixed initial state multiplicity (tests)
*         keyrad=10k0010 fixed final   state multiplicity (tests)
* npar(2)=keypia=0,1 photon removal switch
* npar(3)=keywgt=0,1 unweighted/weighted events
* xpar(1)=cmsene  =  mass of z0
* xpar(2)=amaz    =  mass of z0
* xpar(3)=sinw2   =  sin(thetaweinberg)**2
* xpar(4)=gammz   =  width of z0
* xpar(5)=amfin   =  mass of final fermion
* xpar(6)=vvmin   =  minimum v-variable (dimesionless) =epsilon
* xpar(7)=vvmax   =  maximum v-variable
********** output
* fourmomenta and photon multiplicity in /momset/
* xpar(10)=xsecnb = cross section in nanobarns
* xpar(11)=errel  = relative error (DIMENSIONless)
* xpar(12)=xsmc   = cross section in r-units
* npar(10)=nevacc = number of generated events
***************************
* for advanced users only:
* (1) one may use keyrad < 0  for running at fixed v-variable,
* in this case all events have  v=vmax precisely.
* (2) for keywgt=1 weighted events are generated and the user should
* use the weight wtmod from the COMMON block /wgtall/.
* wtmod is the actual model weight depending on other input params.
* the other interesting possibility is to use
*     wt=wtcru1*wtcru2*wtset(i) where
*     wtset(71) =   zero-th order initial+final
*     wtset(72) =   first order   initial+final
*     wtset(73) =   second order  initial+final
* and the following provide the corresponding components of x-section.
*     wtset(80) =   first order, beta0 contribution alone
*     wtset(81) =   first order, beta1 contribution alone
*     wtset(90) =   second order, beta0 contribution alone
*     wtset(91) =   second order, beta1 contribution alone
*     wtset(92) =   second order, beta2 contribution alone
* furthermore, for the initial state alone we provide
*     wtset( 1) =   zero-th order initial
*     wtset( 2) =   first order   initial
*     wtset( 3) =   second order  initial
* and the corresponding components
*     wtset(20) =   first order, beta0 contribution alone
*     wtset(21) =   first order, beta1 contribution alone
*     wtset(30) =   second order, beta0 contribution alone
*     wtset(31) =   second order, beta1 contribution alone
*     wtset(32) =   second order, beta2 contribution alone
* n.b. wtmod=wtcru1*wtcru2*wtset(71)
*     ************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER(pi=3.1415926535897932d0,alfinv=137.03604d0)
      DIMENSION  xpar( *),npar( *)
      COMMON / cmonit/ averwt,errela,nevtot,nevacc,nevneg,nevove,nevzer
      COMMON / momset / qf1(4),qf2(4),sphum(4),sphot(100,4),nphot
      COMMON / momini / xf1(4),xf2(4),xphum(4),xphot(100,4),nphox
      COMMON / momfin / yf1(4),yf2(4),yphum(4),yphot(100,4),nphoy
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf
      COMMON / wgtall / wtmod,wtcru1,wtcru2,wtset(100)
      COMMON / keyyfs / keyzet,keybrm,keyfix,keypia,keywgt
      COMMON / inout  / ninp,nout
      COMMON / bxfmts / bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      DIMENSION xxf(4)
      SAVE   / cmonit /,/ momset /,/ momini /,/ momfin /,/ weking /
      SAVE   / wgtall /,/ keyyfs /,/ inout  /,/ bxfmts /
      SAVE   nevgen,keybin,keybfi,cmsene
      SAVE   idyfs, wtmax
      SAVE   gnanob,sig0nb,xcrunb

      IF(mode .EQ. -1) THEN
*     ==================================================================
*     =====================initialization===============================
*     ==================================================================

 6900 FORMAT('1',10(/,10x,a))
      WRITE(nout,6900)
     $'  *************************************************************',
     $'  *  ****   ****  **********    *******          ***********  *',
     $'  *  ****   ****  **********  **********         **********   *',
     $'  *   **** ****   ****        *****                 ******    *',
     $'  *    ******     ********      ******    *****    ******     *',
     $'  *     ****      ********         *****  *****      ******   *',
     $'  *     ****      ****        **********         ***********  *',
     $'  *     ****      ****         *******           **********   *',
     $'  *************************************************************',
     $' '

      CALL filexp(xpar,npar)
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
! identificator for this generator
      idgen = 6
! important histo which remembers total x-section
      CALL gmonit(  -1, idgen,1d0,1d0,1d0)
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
*     gmonit monitors weights
      idyfs = 0
      CALL gmonit(-1,idyfs+71,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+72,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+73,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+74,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+75,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+78,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+79,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+80,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+81,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+90,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+91,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+92,0d0,1d0,1d0)
      CALL gbook1(idyfs +5,'wt expand  nphot.ne.0  $', 60 ,-1d0, 5d0)
      CALL gbook1(idyfs+11,'photon multiplicity    $', 50,  0d0,50d0)
      cmsene = 2d0*ene
      keybin = MOD(keybrm,10)
      keybfi = MOD(keybrm,100)/10
      IF(keybin .EQ. 1) THEN
         CALL karlud(-1,xcru,dum2,amfi1,amfi2)
      ELSE
         xcru  = borny(cmsene**2)
      ENDIF
      gnanob=389.385d-30*1.d33
      sig0nb =  4d0*pi/(alfinv**2*3d0*cmsene**2)*gnanob
      xcrunb = xcru*sig0nb
      IF(keybfi .EQ. 1) CALL karfin(-1, xxf,dumm1,dumm2,dumm3)
      CALL  model(-1,dum1,dum2)
      nevgen=0

      ELSEIF(mode  .EQ.  0) THEN
*     ==================================================================
*     =====================generation===================================
*     ==================================================================
      nevgen=nevgen+1
  100 CONTINUE
* ===================
*     Final state masses may be now different (for W pair production)
         amfi1 = amfin
         amfi2 = amfin
* Initial state yfs2 type generator
         IF(keybin .EQ. 1) THEN
            CALL karlud( 0,wtkarl,dum2,amfi1,amfi2)
         ELSE
            CALL givpair(cmsene,amfi1,amfi2,xf1,xf2)
            wtkarl = 1d0
            nphox  = 0
         ENDIF
* Four-momentum of virtual Z
         DO k=1,4
            xxf(k) = xf1(k)+xf2(k)
         ENDDO
* ===================
* final state momenta in the Z frame
         IF(keybfi .EQ. 1) THEN
            CALL karfin(0, xxf,amfi1,amfi2,wtcfin)
         ELSE
* no final state bremss, fermion momenta defined in z frame
            CALL kinf2( xxf,amfi1,amfi2,yf1,yf2)
            wtcfin = 1d0
            nphoy  = 0
         ENDIF
* merging momenta and transform to cms frame
         CALL mergif
* =================== all kinematics is fixed at this point =======
         wtcru1 = wtkarl
         wtcru2 = wtcfin
         wtcrud = wtkarl*wtcfin
* =================== all weights are fixed at this point =========
*ccc     IF(nevgen .LE. 5) CALL dumpi(nout)
*ccc     IF(nevgen .LE. 5) CALL dumpf(nout)
* model weight
         CALL model(0,wtmax,wtmdl)
* principal model weight for wt=1 events (after rejection)
         wt     = wtcrud*wtmdl
* weigt monitoring
         CALL gmonit(0,idyfs+73,wtcrud*wtset(73),wtmax,0d0)
         CALL gmonit(0,idyfs+72,wtcrud*wtset(72),wtmax,0d0)
         CALL gmonit(0,idyfs+71,wtcrud*wtset(71),wtmax,0d0)
         CALL gmonit(0,idyfs+75,wtcrud*(wtset(73)-wtset(72)),wtmax,0d0)
         CALL gmonit(0,idyfs+74,wtcrud*(wtset(72)-wtset(71)),wtmax,0d0)
         CALL gmonit(0,idyfs+80,wtcrud*wtset(80),wtmax,0d0)
         CALL gmonit(0,idyfs+81,wtcrud*wtset(81),wtmax,0d0)
         CALL gmonit(0,idyfs+90,wtcrud*wtset(90),wtmax,0d0)
         CALL gmonit(0,idyfs+91,wtcrud*wtset(91),wtmax,0d0)
         CALL gmonit(0,idyfs+92,wtcrud*wtset(92),wtmax,0d0)
* test histograms
         xmult=float(nphot)+.1d0
         CALL gf1(idyfs+11,xmult,1d0)
         IF(nphot .GE. 0) CALL gf1(idyfs+5,wt,1d0)
* rejection according to principal weight
         IF(keywgt .EQ. 0) THEN
            CALL gmonit(0, idgen, xcrunb*wtmax, wtmax, 1d0)
* constant-weight events with wt=1
            CALL varran(rn,1)
            CALL gmonit(0,idyfs+79,wt ,wtmax,rn)
            IF(rn  .GT.  wt/wtmax) GOTO 100
            wtmod=1.d0
* wtcru1,2  weights are reset to one
            wtcru1=1d0
            wtcru2=1d0
         ELSE
* variable-weight events
            wtmod  = wtcrud*wtmdl
            CALL gmonit(0, idgen, xcrunb,      wtmax, 1d0)
            CALL gmonit(0,idyfs+79,wt     ,wtmax,0d0)
            CALL gmonit(0,idyfs+78,wtcrud ,wtmax,0d0)
         ENDIF

      ELSEIF(mode .EQ. 1 .OR. mode .EQ. 2) THEN
*     ==================================================================
*     =====================final weight analysis========================
*     ==================================================================
      xbornb =  borny(cmsene**2)*sig0nb
      IF(keybin .EQ. 1) THEN
         CALL karlud(mode,xkarl,erkarl,amfi1,amfi2)
      ELSE
         xkarl  = borny(cmsene**2)
         erkarl = 0d0
      ENDIF
      IF(keybfi .EQ. 1) CALL karfin(mode,xxf,dumm1,dumm2,dumm3)
*
      CALL gmonit(1,idyfs+79,dumm1,dumm2,dumm3)
      npar(10)= nevgen
      xsmc   =  xkarl*averwt
      erel   =  sqrt(erkarl**2+errela**2)
      erabs  =  xsmc*erel
      xsmcnb =  xsmc*sig0nb
      erabs2 =  xsmcnb*erel
      xpar(10)= xsmcnb
      xpar(11)= erel
      xpar(12)= xsmc
      IF(keywgt .EQ. 0) THEN
* weighted events, normal option
         xpar(20)=xsmcnb
         xpar(21)=erel
         xpar(22)=xsmc
      ELSE
* weighted events, additional inFORMATion on x-sections
         CALL gmonit(1,idyfs+78,dumm1,dumm2,dumm3)
         xpar(20)= xkarl*sig0nb
         xpar(21)= errela
         xpar(22)= xkarl
      ENDIF
* no printout for mode =1
      IF(mode .EQ. 1) RETURN
*[[[    CALL gprint(idyfs+11)
      CALL gprint(idyfs+ 5)
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'expand output - window a'
      WRITE(nout,bxl1f) cmsene,     'cms energy total   ','cmsene','a0'
      WRITE(nout,bxl2f) xsmc,erabs, 'xs_tot mc r-units  ','xsmc  ','a1'
      WRITE(nout,bxl1f) xsmcnb,     'xs_tot    nanob.   ','xsmcnb','a3'
      WRITE(nout,bxl1f) erabs2,     'absolute error     ','erabs2','a4'
      WRITE(nout,bxl1f) erel,       'relative error     ','erel  ','a5'
      WRITE(nout,bxl1i) nevtot,     'total no of events ','nevtot','a6'
      WRITE(nout,bxl1i) nevacc,     'accepted    events ','nevacc','a7'
      WRITE(nout,bxl1i) nevneg,     'wt<0        events ','nevneg','a8'
      WRITE(nout,bxl1i) nevove,     'wt>wtmax    events ','nevove','a9'
      WRITE(nout,bxl1f) wtmax ,     'wtmax              ','wtmax ','a10'
      WRITE(nout,bxl1f) xbornb,     'xs_born   nanob.   ','xbornb','a11'
      WRITE(nout,bxclo)
*     ==================================================================
*     =============suppl. final weight analysis=========================
*     ==================================================================
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) '        expand output - window b '
      WRITE(nout,bxtxt) '           x-sections in r-units '
      CALL gmonit(1,idyfs+73,dumm1,dumm2,dumm3)
      xs03   =  xkarl*averwt
      dxs03  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      CALL gmonit(1,idyfs+72,dumm1,dumm2,dumm3)
      xs02   =  xkarl*averwt
      dxs02  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      CALL gmonit(1,idyfs+71,dumm1,dumm2,dumm3)
      xs01   =  xkarl*averwt
      dxs01  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      CALL gmonit(1,idyfs+75,dumm1,dumm2,dumm3)
      xs05   =  xkarl*averwt
      dxs05  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      CALL gmonit(1,idyfs+74,dumm1,dumm2,dumm3)
      xs04   =  xkarl*averwt
      dxs04  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      WRITE(nout,bxl2f) xs03,dxs03,'x-section','o(alf2)',  'b1'
      WRITE(nout,bxl2f) xs02,dxs02,'x-section','o(alf1)',  'b2'
      WRITE(nout,bxl2f) xs01,dxs01,'x-section','o(alf0)',  'b3'
      IF(xs02.ne.0d0) WRITE(nout,bxl2f)
     $ xs05/xs02,dxs05/xs02,'(o(alf2)-o(alf1))','/o(alf1)','b4'
      IF(xs01.ne.0d0) WRITE(nout,bxl2f)
     $ xs04/xs01,dxs04/xs01,'(o(alf1)-o(alf0))','/o(alf0)','b5'
      WRITE(nout,bxclo)
* -------------
      wtcru1 = xkarl
      wtcru2 = erkarl
      CALL  model(mode,dumm1,dumm2)
* -------------
      ELSE
*     ====
      WRITE(nout,*) '===>expand: wrong mode'
      STOP
      ENDIF
*     =====
      END

      SUBROUTINE mergif
*     *****************
* merging two COMMONs all photons together
* transFORMATion to COMMON (cms) trame is supposed to be alREADy DOne
*     ************************************
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      COMMON / momset / qf1(4),qf2(4),sphum(4),sphot(100,4),nphot
      COMMON / momini / xf1(4),xf2(4),xphum(4),xphot(100,4),nphox
      COMMON / momfin / yf1(4),yf2(4),yphum(4),yphot(100,4),nphoy
* photons
      nphot  = 0
      DO i=1,nphox
         nphot  =nphot+1
         DO k=1,4
            sphot(nphot,k)=xphot(i,k)
         ENDDO
      ENDDO
      DO  i=1,nphoy
         nphot  =nphot+1
         DO  k=1,4
            sphot(nphot,k)=yphot(i,k)
         ENDDO
      ENDDO
* final state fermions
      DO k=1,4
         qf1(k)= yf1(k)
         qf2(k)= yf2(k)
      ENDDO
* axiliary
      DO k=1,4
         sphum(k)= xphum(k)+yphum(k)
      ENDDO
      END

      SUBROUTINE filexp(xpar,npar)
*     ***********************************
* transfers and defines input params, prints input PARAMETERs
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      DIMENSION  xpar( *),npar( *)
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf
      COMMON / keyyfs / keyzet,keybrm,keyfix,keypia,keywgt
      COMMON / spiset / polar1,polar2,polfi1,polfi2
      COMMON / uurec  / uu,eps,delta
      COMMON / vvrec  / vvmin,vvmax,vv,gami
      COMMON / inout  / ninp,nout
      COMMON / bxfmts / bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      COMMON / ranpar / keyrnd
      SAVE / weking /,/ keyyfs /,/ spiset /,/ uurec  /,/ vvrec  /
      SAVE / inout  /,/ bxfmts /,/ ranpar /

* bx-FORMATs for nice and flexible outputs
      bxope =  '(//1x,15(5h*****)    )'
      bxtxt =  '(1x,1h*,                  a48,25x,    1h*)'
      bxl1i =  '(1x,1h*,i17,                 16x, a20,a12,a7, 1x,1h*)'
      bxl1f =  '(1x,1h*,f17.8,               16x, a20,a12,a7, 1x,1h*)'
      bxl2f =  '(1x,1h*,f17.8, 4h  +-, f11.8, 1x, a20,a12,a7, 1x,1h*)'
      bxl1g =  '(1x,1h*,g17.8,               16x, a20,a12,a7, 1x,1h*)'
      bxl2g =  '(1x,1h*,g17.8, 4h  +-, f11.8, 1x, a20,a12,a7, 1x,1h*)'
      bxclo =  '(1x,15(5h*****)/   )'

*  type of the random number generator ranmar
      keyrnd = 1
*----------
      keybrm= abs(npar(1))
      keyfix= 0
      IF(npar(1) .LT. 0) keyfix=1
      keypia= npar(2)
      keywgt= npar(3)
      keyzet= npar(4)
      cmsene = xpar(1)
      amaz   = xpar(2)
      sinw2  = xpar(3)
      gammz  = xpar(4)
      amfin  = xpar(5)
      vvmin  = xpar(6)
      vvmax  = xpar(7)
      ene    = cmsene/2d0
      vvmax  = min(vvmax,1d0-(amfin/ene)**2)
      eps    = vvmin
      delta  = eps*1d-3
      polar1 = 0d0
      polar2 = 0d0
      polfi1 = 0d0
      polfi2 = 0d0
      amel   = 0.5111d-3
      ide=2
      idf=2
      xk0=3.d-3
*
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) '    yfs version 3.30   febr.  93        '
      WRITE(nout,bxl1f) cmsene,     'cms energy total   ','cmsene','a0'
      WRITE(nout,bxl1i) keybrm,     'general qed switch ','keybrm','a1'
      WRITE(nout,bxl1f) amfin,      'final fermionmass  ','amfin ','a2'
      WRITE(nout,bxl1f) amaz,       'z mass   [gev]     ','amaz  ','a3'
      WRITE(nout,bxl1f) gammz,      'z width  [gev]     ','gammz ','a4'
      WRITE(nout,bxl1f) sinw2,      'sin(theta_w)**2    ','sinw2 ','a5'
      WRITE(nout,bxl1f) vvmin,      'dummy infrared cut ','vvmin ','a6'
      WRITE(nout,bxl1f) vvmax,      'v_max ( =1 )       ','vvmax ','a7'
      WRITE(nout,bxl1i) keypia,     'removal    switch  ','keypia','a8'
      WRITE(nout,bxl1i) keywgt,     'weighting  switch  ','keywgt','a9'
      WRITE(nout,bxl1i) keyzet,     'elect_weak switch  ','keyzet','a10'
      WRITE(nout,bxclo)
      END

      SUBROUTINE karlud(mode,par1,par2,amfi1,amfi2)
*     *********************************************
* low level  monte-carlo generator
* administrates directly generation of v-variable
* and indirectly of all other variables.
*     ************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER (pi=3.1415926535897932d0,alfinv= 137.03604d0)
      PARAMETER (ceuler =0.57721566d0)
      PARAMETER (nmax= 40)
      COMMON / momini / qf1(4),qf2(4),sphum(4),sphot(100,4),nphot
      COMMON / sudini / yini(100),zini(100)
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf
      COMMON / keyyfs / keyzet,keybrm,keyfix,keypia,keywgt
* communicates with vesko/rhosko
      COMMON / vvrec  / vvmin,vvmax,vv,gami
      COMMON / inout  / ninp,nout
* communicates with gmonit
      COMMON / cmonit/ averwt,errela,nevtot,nevacc,nevneg,nevove,nevzer
      COMMON / bxfmts / bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      DIMENSION qq(4)
      SAVE
      EXTERNAL rhosko
* maximum photon multiplicity
*
      IF(mode .EQ. -1) THEN
*     ==================================================================
*     ===================initialization=================================
*     ==================================================================
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'initialize karlud  start'
      svar = 4d0*ene**2
      gami = 2d0/alfinv/pi*(dlog(4d0*ene**2/amel**2)-1d0)
      gami2= 2d0/alfinv/pi* dlog(4d0*ene**2/amel**2)
      gamfap =1d0-pi**2*gami**2/12d0
      gamfac =exp(-ceuler*gami)/dpgamm(1d0+gami)
      gamfa2 =exp(-ceuler*gami2)/dpgamm(1d0+gami2)
      idyfs = 0
      CALL gbook1(idyfs+ 7,'wt in karlud         $', 50 , 0d0,5d0)
      CALL gmonit(-1,idyfs+51,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+52,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+53,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+54,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+55,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+56,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+59,0d0,1d0,1d0)
      CALL vesk1w(-1,rhosko,xcvesk,dum1,dum2)
      par1 = xcvesk
      prec = 1d-5
      xcgaus =bremkf(1,prec)
      xdel = xcvesk/xcgaus-1
      WRITE(nout,bxl1f) xcvesk,     'xs_crude  vesko    ','xcvesk','  '
      WRITE(nout,bxl1f) xcgaus,     'xs_crude  gauss    ','xcgaus','  '
      WRITE(nout,bxl1f) xdel       ,'xcvesk/xcgaus-1    ','      ','  '
      WRITE(nout,bxtxt) 'initialize karlud  END  '
      WRITE(nout,bxclo)
      ELSEIF(mode .EQ. 0) THEN
*     ==================================================================
*     ====================generation====================================
*     ==================================================================
   30 CONTINUE
* generate vv
      IF(keyfix .EQ. 0) THEN
        CALL vesk1w( 0,rhosko,dum1,dum2,wtves)
      ELSE
        wtves=1d0
        vv=vvmax
      ENDIF
*-------------------------------------------------------------
*     low-level multiphoton generator
*-------------------------------------------------------------
      CALL yfs_ini(ene,amel,vv,vvmin,nmax,
     $              nphot,sphot,sphum,yini,zini,wt1,wt2,wt3)

* define final fermion momenta (used for initial state alone)
* qq is four-momentum of final state fermion pair
      DO k=1,4
         qq(k)=-sphum(k)
      ENDDO
      qq(4)=qq(4)+2d0*ene
      CALL kinf2( qq,amfi1,amfi2,qf1,qf2)
*-------------------------------------------------------------
* tests on internal weights
* does not interfere with the event generation !!!
*-------------------------------------------------------------
      ref  = vvrho(50,svar,amel,vv,vvmin)
      wtr  = ref/vvrho(1,svar,amel,vv,vvmin)
      CALL varran(rn,1)
      CALL gmonit(0,idyfs+56,wtr,1d0,rn)
* pseudorejection in order to introduce reference xsection
      IF(keyfix .EQ. 0  .AND.  rn .GT. wtr) GOTO 110
      wf1  = wt1*vvrho(51,svar,amel,vv,vvmin)/ref
      wf2  = wt2*vvrho(52,svar,amel,vv,vvmin)/ref
      wf3  = wt3
      wf13 = wf1*wf3
      wf123= wf1*wf2*wf3
      CALL gmonit(0,idyfs+51,wf1,  1d0,1d0)
      CALL gmonit(0,idyfs+52,wf2,  1d0,1d0)
      CALL gmonit(0,idyfs+53,wf3,  1d0,1d0)
      CALL gmonit(0,idyfs+54,wf13, 1d0,1d0)
      CALL gmonit(0,idyfs+55,wf123,1d0,1d0)
  110 CONTINUE
*--------------
      wt=wtves*wt1*wt2*wt3
      wtkarl=wt
      CALL gmonit(0,idyfs+59,wt,  1d0,1d0)
      CALL gf1(idyfs+ 7,wt,1d0)
      par1=wt
      ELSE
*     ==================================================================
*     ====================final weight analysis=========================
*     ==================================================================
      CALL gprint(idyfs+ 7)
      CALL gmonit(1,idyfs+59,dumm1,dumm2,dumm3)
      wtkarl = averwt
      erkrl  = errela
      prec   = 1d-5
      xsgs   = bremkf(1,prec)
      ergs   = xsgs*prec
      CALL vesk1w( 1,rhosko,xsve,erelve,xcvesk)
      erve   = xsve*erelve
      IF(keyfix .EQ. 1)  xcvesk=xcgaus
* note that since vesk1w produces weighted events we are sending
* up the crude x-section (from vesk1w) to the CALLing PROGRAM
      par1   = xcvesk
      par2   = 0d0
* no printout for mode = 2
      IF(mode .EQ. 1) RETURN
      ddv    = xsve/xsgs-1d0
      ddr    = erelve + 1d-6
      xskr   = xcvesk*wtkarl
      erkr   = xskr*erkrl
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) '     karlud  final  report     '
      WRITE(nout,bxtxt) '         window a              '
      WRITE(nout,bxl1i) nevtot,     'total no of events ','nevtot','a0'
      WRITE(nout,bxl1i) nevneg,     'wt<0        events ','nevneg','a1'
      WRITE(nout,bxl1f) xcvesk,     'xs_cru vesko  [r]  ','xcvesk','a2'
      WRITE(nout,bxl2f) xsve,erve,  'xs_est vesko  [r]  ','xsve  ','a3'
      WRITE(nout,bxl2f) xsgs,ergs,  'xs_est gauss  [r]  ','xsgs  ','a4'
      WRITE(nout,bxl2f) ddv,ddr,    'xcve/xcgs-1        ','      ','a5'
      WRITE(nout,bxl2f) wtkarl,erkrl,'   <wt>           ','wtkarl','a6'
      WRITE(nout,bxl2f) xskr,erkr,  'sigma_prim    [r]  ','xskarl','a7'
      WRITE(nout,bxclo)
*     ==================================================================
*     =============suppl. final weight analysis=========================
*     ==================================================================
      CALL gmonit(1,idyfs+51,dumm1,dumm2,dumm3)
      del1   = averwt-1d0
      dwt1   = errela
      CALL gmonit(1,idyfs+52,dumm1,dumm2,dumm3)
      awf2   = averwt
      dwt2   = errela
      CALL gmonit(1,idyfs+53,dumm1,dumm2,dumm3)
      awf3   = averwt
      del3   = averwt-gamfa2
      dwt3   = errela
      CALL gmonit(1,idyfs+54,dumm1,dumm2,dumm3)
      awf4   = averwt
      del4   = averwt-gamfac
      dwt4   = errela
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) '     karlud  final  report     '
      WRITE(nout,bxtxt) '         window b              '
      WRITE(nout,bxl2f) del1,dwt1,  '<wf1>-1  mass wt   ','del1  ','b1'
      WRITE(nout,bxl2f) awf2,dwt2,  '<wf2> dilat. weight','awf2  ','b2'
      WRITE(nout,bxl2f) awf3,dwt3,  '<wf3> dilat. weight','awf3  ','b3'
      WRITE(nout,bxl2f) del3,dwt3,  '<wf3>-ygf(gami2)   ','del3  ','b4'
      WRITE(nout,bxl2f) awf4,dwt4,  '<wf1*wf3>          ','awf4  ','b5'
      WRITE(nout,bxl2f) del4,dwt4,  '<wf1*wf3>-ygf(gami)','del4  ','b6'
      WRITE(nout,bxclo)
*     ==================================================================
      ENDIF
*     =====
      END
      FUNCTION rhosko(r)
*     ********************
* Called in vesk1w
* Provides v or k distribution to be generated
*     ********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER (fleps = 1d-35)
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf
      COMMON / keyyfs / keyzet,keybrm,keyfix,keypia,keywgt
      COMMON / vvrec  / vvmin,vvmax,vv,gami
* Mapping  r => vv change  to improve on efficiency
* Note that the replacement below makes program more precise
* and bullet-proof with respect numerical instabilities close to vv=0
      x = max(r,fleps**gami)
      bbt = -0.5d0
      CALL chbin1(x,gami,bbt,vvmax,vv,rjac)
* born xsection
* note 1/(1-vv) factor because borny is in r-units
      svar   = 4d0*ene**2
      svar1  = svar*(1d0-vv)
      xborn  = borny(svar1)/(1d0-vv)
* constant x-section for tests
      IF(keyzet .EQ. -2) xborn = xborn * (1d0-vv)
      rhosko = rjac*xborn* vvrho(1,svar,amel,vv,vvmin)
      END

      SUBROUTINE yfs_ini(ene,amel,vv,vmin,nmax,
     $                   nphot,sphot,sphum,ygr,zet,wt1,wt2,wt3)
*     *********************************************************
*======================================================================
*================== y f s g e n =======================================
*======================================================================
**********INPUT
* ene   = initial beam energy
* amel  = beam mass
* vv    = v variable
* vmin  = minimum v variable (infrared cutoff)
* nmax  = maximum photon multiplicity
**********output
* nphot   = photon multiplicity
* sphot   = photon four-momenta
* sphum   = total photon four-momentum
* ygr,zet = Sudakov variables
* wt1     = weight due to neglected mass terms
* wt2     = weight due to dilatation of photon momenta
* wt3     = another dilatation weight
* other output results in /momini/
******************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( pi=3.1415926535897932d0,alfinv= 137.03604d0)
      DIMENSION sphum(4),sphot(100,4),ygr(100),zet(100)
* for tests only
      COMMON / keyyfs / keyzet,keybrm,keyfix,keypia,keywgt
      SAVE   / keyyfs / 
      DIMENSION xph(100),rr(100)
*
* here gami2 must be used instead of gami (mass term neglected)
      am2  = (amel/ene)**2
      beta = sqrt(1d0-am2)
      gami2 = 2d0/alfinv/pi* dlog((1+beta)**2/am2)
      DO i=1,nmax
         xph(i)=0d0
         ygr(i)=0d0
         zet(i)=0d0
         DO j=1,4
            sphot(i,j)=0d0
         ENDDO
      ENDDO
      IF(vv .LE. vmin) THEN
* no photon above detectability threshold
         wt1=1d0
         wt2=1d0
         wt3=1d0
         nphot=0
      ELSE
* one or more photons, generate photon multiplicity
* nphot = poisson(with average = averg) + 1
         averg=gami2*dlog(vv/vmin)
 100     CONTINUE
         CALL poissg(averg,nmax,multp,rr)
         nphot = multp+1
* this is for tests of PROGRAM at fixed multiplicity (for adv. users)
         nphfix =  MOD(keybrm,10000)/1000
         IF(nphfix.ne.0 .AND. nphot.ne.nphfix) GOTO 100
         IF(nphot .EQ. 1) THEN
            xph(1)=vv
         ELSE
            xph(1)=vv
            DO i=2,nphot
               xph(i)=vv*(vmin/vv)**rr(i-1)
            ENDDO
         ENDIF ! nphot
         wt1=1d0
         DO i=1,nphot
            xk=xph(i)
            CALL angbre(am2,del1,del2,cg,sg,dist0,dist1)
            wtm=dist1/dist0
            wt1    =wt1*wtm
            CALL varran(rnumb,1)
            phi=2d0*pi*rnumb
            sphot(i,1)=xk*sg*cos(phi)
            sphot(i,2)=xk*sg*sin(phi)
            sphot(i,3)=xk*cg
            sphot(i,4)=xk
            ygr(i)    =xk*del1/2d0
            zet(i)    =xk*del2/2d0
         ENDDO
         CALL resolh(sphot,nphot,vv,expy,djac)
         djac0=(1d0+1d0/sqrt(1d0-vv))/2d0
         wt2  = djac/djac0
         wt3  = 1d0
* scale down photon energies and momenta
         DO i=1,nphot
            ygr(i) =ygr(i)/expy
            zet(i) =zet(i)/expy
            DO k=1,4
               sphot(i,k)=sphot(i,k)/expy
            ENDDO
         ENDDO
* check on lower energy cut-off
         IF(sphot(nphot,4) .LT. vmin) wt3 =0d0
      ENDIF ! vv
* photon momenta rescaled into GEV units
      DO j=1,4
         sphum(j)=0d0
      ENDDO
      DO  i=1,nphot
         DO  j=1,4
            sphot(i,j)=sphot(i,j)*ene
            sphum(j)=sphum(j)+sphot(i,j)
         ENDDO
      ENDDO
      END

      SUBROUTINE resolh(sphot,nphot,vv,expy,djac)
*     *******************************************
* this solves constraint equation on photon momenta
* also calculates corresponding jacobian factor
* input:  sphot = crude photon momenta
*         nphot = photon multiplicity
*         vv    = costraint parameter v
* output  expy  = rescaling factor - a solution of the equation
*         djac  = jacobian factor
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION sphot(100,4)
      DIMENSION pp(4),pk(4)
*
      IF(nphot .EQ. 1) THEN
         expy = 1
         djac = 1
         RETURN
      ENDIF
*
      DO k=1,4
         pk(k)=0d0
         pp(k)=0d0
      ENDDO
      pp(4)=2d0    ! total energy in units of ene
      DO i=1,nphot
         DO k=1,4
            pk(k)=pk(k)+sphot(i,k)
         ENDDO
      ENDDO
      ppdpp=pp(4)**2-pp(3)**2-pp(2)**2-pp(1)**2
      pkdpk=pk(4)**2-pk(3)**2-pk(2)**2-pk(1)**2
      ppdpk=pp(4)*pk(4)-pp(3)*pk(3)-pp(2)*pk(2)-pp(1)*pk(1)
      aa=ppdpp*pkdpk/(ppdpk)**2
      expy=2d0*ppdpk/ppdpp/vv
* solution for constraint on photon four momenta
      expy=expy*.5d0*(1d0+sqrt(1d0-vv*aa))
* jacobian factor
      djac=(1d0+1d0/sqrt(1d0-vv*aa))/2d0
      END
*======================================================================
*==================end of  y f s g e n ================================
*======================================================================


      SUBROUTINE karfin(mode, ppz,amfi1,amfi2,wt)
*     *******************************************
* ======================================================================
*  low level monte carlo for final state multibremsstrahlung
* ======================================================================
* input:
*         ppz    = cms four momentum of the entire final state
*  system i.e. fermions + photons
*         amfin  = mass of final state fermion
* hidden input:  eps, delta in /vvrec/, FORMATs in /bxfmts/
* output:
*            wt  = crude mc weight
*         momenta in /momfin/
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION ppz(4)
      COMMON / keyyfs / keyzet,keybrm,keyfix,keypia,keywgt
      COMMON / momfin / qf1(4),qf2(4),sphum(4),sphot(100,4),nphot
      COMMON / sudfin / yfin(100),zfin(100)
      COMMON / uurec  / uu,eps,delta
* communicates with gmonit
      COMMON / cmonit/ averwt,errela,nevtot,nevacc,nevneg,nevove,nevzer
      COMMON / inout  / ninp,nout
      DIMENSION  mk(100), wtmas(100)
      DIMENSION  qf1c(4),qf2c(4)
      COMMON / bxfmts / bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      SAVE
      SAVE nevgen,martot,idyfs
*
      IF(mode .EQ. -1) THEN
*     ===================
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'initialize karfin  start'
      idyfs = 0
      CALL gbook1(idyfs+20,'karfin: log10(k/eps) marked $',50, 0d0, 5d0)
* additional check on wtctrl, plot of its u-dependence
      CALL gbook1(idyfs+31,'karfin:     u  wtctrl       $',27,.1d0, 1d0)
      CALL gbook1(idyfs+32,'karfin:     u  wt=1         $',27,.1d0, 1d0)
      CALL gmonit(-1,idyfs+60,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+61,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+62,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+63,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+64,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+65,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+66,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+69,0d0,1d0,1d0)
      nevgen=0
      martot=0
      WRITE(nout,bxtxt) 'initialize karfin  END  '
      WRITE(nout,bxclo)
*
      ELSEIF(mode .EQ. 0) THEN
*     ======================
      nevgen=nevgen+1
      svar = ppz(4)**2-ppz(3)**2-ppz(2)**2-ppz(1)**2
      cmsene = sqrt(svar)
      emin = eps*cmsene/2
* generate photons and fermions in the rest frame of fermions Q=qf1+qf2
      CALL yfs_fin(svar,amfi1,amfi2,delta,
     $   nphot,sphot,sphum,yfin,zfin,mk,qf1,qf2,qf1c,qf2c,wt1,wt2,wtmas)
* transform from rest frame of Q=qf1+qf2, 
* through ppz=qf1+qf2+sphum, down to CMS=Lab
      CALL kinf1(ppz,qf1,qf2,qf1c,qf2c,nphot,sphot,sphum)
      wt3=1d0
      wctrl=1d0
      wtrem=1d0
      IF(wt1.ne.0.d0) THEN
* Calculate YFS formfactor (cut-off dependent part) and mass weights
* Optionally removing photons below epsilon from the list
         CALL piatek(keypia,amfi1,amfi2,emin,delta,
     $        qf1,qf2,qf1c,qf2c,sphum,sphot,nphot,wtmas,wtrem,wt3,wctrl)
      ENDIF
      uu=svar/cmsene**2
      CALL gmonit(0,idyfs+64,1d0*nphot,20d0,0d0)
      CALL gmonit(0,idyfs+65,wctrl,1d0,0d0)
      CALL gf1(idyfs+31, uu  ,wctrl)
      CALL gf1(idyfs+32, uu  ,  1d0)
      CALL gmonit(0,idyfs+66,wtrem,1d0,0d0)
* Monitoring weights
      CALL gmonit(0,idyfs+60,1d0*nphot,20d0,0d0)
      CALL gmonit(0,idyfs+61,wt1,1d0,0d0)
      CALL gmonit(0,idyfs+62,wt2,1d0,0d0)
      CALL gmonit(0,idyfs+63,wt3,1d0,0d0)
* marked photons
      IF(nphot .GE. 1) THEN
         DO i=1,nphot
            xk= sphot(i,4)/emin
            ul= log10(xk)
            IF(mk(i) .EQ. 1)   CALL gf1(idyfs+20,   ul,1.d0)
            IF(mk(i) .EQ. 1)   martot=martot+1
         ENDDO
      ENDIF
* main weight
      wt = wt1*wt2*wt3
      CALL gmonit(0,idyfs+69,wt ,1d0,0d0)
      ELSE
*     ====
* no printout for mode=1
      IF(mode .EQ. 1) RETURN
*-----------------------------------------------------------------------
*.........................output window a...............................
      CALL gmonit(1,idyfs+60,avmult,dumm2,dumm3)
      CALL gmonit(1,idyfs+61,awt61,dwt61,dumm3)
      CALL gmonit(1,idyfs+62,awt62,dwt62,dumm3)
      CALL gmonit(1,idyfs+63,awt63,dwt63,dumm3)
      CALL gmonit(1,idyfs+69,awt69,dwt69,dumm3)
* general information on weights
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'karfin output - window a'
      WRITE(nout,bxtxt) '    weight statistics   '
      WRITE(nout,bxl2f) awt69,dwt69,' general weight    ','wt    ','a1'
      WRITE(nout,bxl1i) nevgen,     ' generated events  ','nevgen','a2'
      WRITE(nout,bxl1f) avmult,     ' aver. ph. multi.  ','avmult','a3'
      WRITE(nout,bxl1i) martot,     ' marked photons    ','martot','a4'
      WRITE(nout,bxl2f) awt61,dwt61,' kinematics, smin  ','wt1   ','a5'
      WRITE(nout,bxl2f) awt62,dwt62,' jacobian          ','wt2   ','a6'
      WRITE(nout,bxl2f) awt63,dwt63,' photon ang. dist. ','wt3   ','a7'
      WRITE(nout,bxclo)
* specific details on mass weight rearrangenment, and rejection
      CALL gmonit(1,idyfs+64,avmlt,dwt65,dumm3)
      CALL gmonit(1,idyfs+65,awt65,dwt65,dumm3)
      CALL gmonit(1,idyfs+66,awt66,dwt66,dumm3)
      nzer66 = nevzer
      ntot66 = nevtot
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'karfin output - window b'
      WRITE(nout,bxtxt) '    on mass weights     '
      WRITE(nout,bxl2f) awt66,dwt66,' removal wgt wtrem ','wt6 ','b1'
      WRITE(nout,bxl1i) ntot66,     ' no. of raw events ','    ','b2'
      WRITE(nout,bxl1i) nzer66,     ' wt6=0      events ','    ','b3'
      WRITE(nout,bxl1f) avmlt,      ' raw ph. multipl.  ','    ','b4'
      WRITE(nout,bxl2f) awt65,dwt65,' control wgt wctrl ','wt5 ','b5'
      WRITE(nout,bxl1g) eps,        ' epsilon           ','    ','b6'
      WRITE(nout,bxl1g) delta,      ' delta             ','    ','b7'
      WRITE(nout,bxclo)
* histograms
*      CALL gprint(idyfs+20)
*      CALL gopera(idyfs+31,'/',idyfs+32,idyfs+33,1d0,1d0)
*      CALL gprint(idyfs+33)
      ENDIF
*     =====
      END


      SUBROUTINE yfs_fin(svar,amch1,amch2,delta,
     $     nphot,phot,phsu,ygr,zet,mk,q1,q2,q1c,q2c,wt1,wt2,wtm)
*     *****************************************************************
* Simulates final state bremsstrahlung (11 march 1989)
* INPUT  : svar     = s variable  (gev)
*          amch1,2  = masses of final fermions
*          delta  = lower energy bound (DIMENSIONless)
* OUTPUT : nphot  = photon multiplicity
*          phot   = photon four momenta (gev) in cms
*          phsu   = sum of photon momenta
*          ygr,zet = Sudakov variables
*          mk     = marks on photons CLOSE to lower energy bound
*          q1,2   = final fermion four momentum (gev)
*          q1c,2c = final fermion four momentum
*          wt1    = the weight - phase space limits for very hard phot.
*          wt2    = the weight - translation jacobian.
*          wtm    = the list of mass weights.
*     **************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER(pi=3.1415926535897932d0,alfinv=137.03604d0)
      DIMENSION phot(100,4),phsu(4),mk(100),wtm(100)
      DIMENSION q1(4),q2(4),q1c(4),q2c(4)
      DIMENSION ygr(100),zet(100)
*
      DIMENSION rr(100),xk(100),cgx(100),sgx(100)
      DIMENSION dis0(100)
      COMMON / inout  / ninp,nout
      COMMON / keyyfs / keyzet,keybrm,keyfix,keypia,keywgt
      SAVE

      amfin = MIN(amch1,amch2)
      wt1=1.d0
      wt2=1.d0
      amc2  = 4.d0*amfin**2/svar  ! overvalued svar for crude
      betc  = sqrt(1d0-amc2)      ! overvalued svar for crude
      DO i=1,100
         rr(i)=0.d0
         mk(i)=0
      ENDDO
      DO k=1,4
         phsu(k)=0.d0
      ENDDO
      DO i=1,100
         ygr(i)=0
         zet(i)=0
         DO k=1,4
            phot(i,k)=0.d0
         ENDDO
      ENDDO
*-----------------------------------------------------------------------
*     generate photon multiplicity, averg = average multiplicity (crude)
*-----------------------------------------------------------------------
      gamf2 = 1/pi/alfinv *(1+betc**2)/betc *dlog((1d0+betc)**2/amc2)
      averg = gamf2*dlog(1/delta)
      nmax=50
    5 CONTINUE
      CALL poissg(averg,nmax,nphot,rr)
** This is for tests of program at fixed multiplicity (advanc. users)
      nphfix =  MOD(keybrm,100000)/10000
      IF(nphfix.ne.0 .AND. nphot.ne.nphfix) GOTO 5
**
      IF(nphot .EQ. 0) THEN
         sprim=svar
      ELSE
*-----------------------------------------------------------------------
*     begin with photon energy
         xsum=0.d0
         DO  i=1,nphot
            xk(i)=delta**rr(i)
            IF(xk(i) .LT. sqrt(10.d0)*delta) mk(i)=1
            xsum=xsum+xk(i)
         ENDDO
         IF(xsum .GE. 1.d0) GOTO 900
         xfact=1d0/(1.d0-xsum)
         DO i=1,nphot
            xk(i)=xk(i)*xfact
         ENDDO
         DO i=1,nphot
*-----------------------------------------------------------------------
*     simplified photon angular distribution,
*     s'->s and m**2/(kp)**2 dropped
*     cg=cos(theta) and sg=sin(theta) memorized to avoid rounding err.
            CALL angbre(amc2,dl1,dl2,cg,sg,dis0(i),dis1)
*-----------------------------------------------------------------------
*     define photon momenta (in units of sqrt(s')/2 )
            CALL varran(rn2,1)
            phi=2.d0*pi*rn2
            phot(i,1)=xk(i)*sg*cos(phi)
            phot(i,2)=xk(i)*sg*sin(phi)
            phot(i,3)=xk(i)*cg
            phot(i,4)=xk(i)
            DO k=1,4
               phsu(k)=phsu(k)+phot(i,k)
            ENDDO
            cgx(i)=cg
            sgx(i)=sg
         ENDDO
*-----------------------------------------------------------------------
*     determine rescaling factor and s', wt2 is dilatation jacobian
         xmk2 = phsu(4)**2-phsu(3)**2-phsu(2)**2-phsu(1)**2
         yy   = 1.d0/(1.d0 +phsu(4) +xmk2/4.d0 )
         wt2  = yy*(1.d0+phsu(4))
         sprim= svar*yy
*-----------------------------------------------------------------------
*     reject events with too hard photons
         smini= (amch1+amch2)**2
         IF(sprim .LT. smini) GOTO 900
*-----------------------------------------------------------------------
*     Recsale properly all photon momenta
*-----------------------------------------------------------------------
         ener = sqrt(sprim)/2.d0
         DO  k=1,4
            phsu(k)= phsu(k)*ener
            DO  i=1,nphot
               phot(i,k)=phot(i,k)*ener
            ENDDO
         ENDDO
      ENDIF ! nphot
*-----------------------------------------------------------------------
*     final fermion momenta
*-----------------------------------------------------------------------
      amcru  = amfin*sqrt(sprim/svar)
      qmsene = sqrt(sprim)
      ener   = qmsene/2d0
      CALL givpair(qmsene,amch1,amch2,q1,q2)   ! real  momenta
      CALL givpair(qmsene,amcru,amcru,q1c,q2c) ! ghost momenta
      betn = sqrt(q1(1)**2+q1(2)**2+q1(3)**2)/ener
      eta1 = q1(4)/ener
      eta2 = q2(4)/ener
*-----------------------------------------------------------------------
*     Mass weight for theta distribution
*-----------------------------------------------------------------------
*     Mass weight compensates for s'->s and droping terms -m**2/(k.q)**2
*     Care is taken of machine rounding errors.
*     del1 and del2 RECALCULATED out of angles sgx(i),cgx(i)
*     with TRUE sprim, using EXACT formulas
      amd1 = (amch1/ener)**2
      amd2 = (amch2/ener)**2
      DO i=1,nphot
         IF( cgx(i) .GT. 0.d0 ) THEN
            del1 = amd1/(eta1+betn) +betn*sgx(i)**2/(1+cgx(i))
            del2 = eta2 +betn*cgx(i)
         ELSE
            del1 = eta1 -betn*cgx(i)
            del2 = amd2/(eta2+betn) +betn*sgx(i)**2/(1-cgx(i))
         ENDIF
         dist1=1d0/(del1*del2) 
     $        *(1d0 -(amd1+amd2)/4d0
     $                   -amd2/4d0*del1/del2 -amd1/4d0*del2/del1)
         wtm(i)= dist1/dis0(i)
         IF(wtm(i) .LT.  1.d-90) wtm(i)= 0.d0
***********
** dist1x below is exactly the same as dist1 but for small masses is 
** prone to severe rounding errors (in contrast to dist1 used above)
*         IF((1-sprim/svar) .gt. 0.01d0) THEN
*            q1q2= q1(4)*q2(4) -q1(3)*q2(3) -q1(2)*q2(2) -q1(1)*q2(1)
*            q1k = q1(4)*phot(i,4)-q1(3)*phot(i,3)
*     $           -q1(2)*phot(i,2)-q1(1)*phot(i,1)
*            q2k = q2(4)*phot(i,4)-q2(3)*phot(i,3)
*     $           -q2(2)*phot(i,2)-q2(1)*phot(i,1)
*            dist1x = 2*q1q2/q1k/q2k -amch1**2/q1k**2 -amch2**2/q2k**2
*            dist1x = dist1x/4d0*phot(i,4)**2
*            WRITE(6,'(a,5f20.10)') '===>: ',dist1x/dist1
*         ENDIF
***********
*     finaly define Sudakov variables
         ygr(i)=del1*xk(i)/2d0
         zet(i)=del2*xk(i)/2d0
      ENDDO
*-----------------------------------------------------------------------
      RETURN
*-----------------------------------------------------------------------
*     event outside phase space
 900  wt1=0.d0
      wt2=1.d0
      nphot=-1
      END


      SUBROUTINE piatek(keypia,amch1,amch2,emin,delta,
     $     qf1,qf2,qf1c,qf2c,phsu,phot,nphot,wtmas,wtrem,wtm3a,wctrl)
*     *****************************************************************
* Written CERN, piatek, 22 sept. 1989  (S.J.)
* Note the action of this routine is not Loretnz invariant !!!!
* Input:  keypia   = 0, NO removal of photons below emin
*                  = 1, with removal of photons below emin
*         amch1,2  = fermion masses
*         emin     = emin minimum-energy of photons to be kept (GeV)
*         delta    = infrared cut-off in generation (dimensionless)
*         qf1,2    = fermion momenta
*         qf1c,2c  = ghost fermion momenta in crude S-factor
*         phsu     = sum of photon momenta
*         phot     = list of photon momenta
*         amch1,2  = fermion masses (GeV)
*         wtmas    = list of mass-weights for all photons
* Output: wtrem    = 1,  for keypia=0
*                  = mass-weight of removed photons, for keypia=1
*         wtm3a    = mass-weight for all photons, see comments below
*         wctrl    = control-weight for remowed photons
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER(pi=3.1415926535897932d0,alfinv=137.03604d0)
      DIMENSION  qf1(4),qf2(4),qf1c(4),qf2c(4),phsu(4),phot(100,4)
      DIMENSION  wtmas(100)
      COMMON / inout  / ninp,nout
      SAVE
      DIMENSION qq(4),pp(4)

      amfin = MIN(amch1,amch2)
      alf1  =  1/pi/alfinv
      DO k=1,4
         pp(k) = qf1(k)+qf2(k) +phsu(k)
         qq(k) = qf1(k)+qf2(k)
      ENDDO
      svar = pp(4)**2-pp(3)**2 -pp(2)**2 -pp(1)**2
      sprim= qq(4)**2-qq(3)**2 -qq(2)**2 -qq(1)**2
      wtm1=1d0
      wtm2=1d0
* mass weight below and above epsilon calculated separately
      DO i=1,nphot
         IF(phot(i,4) .LT. emin) THEN
            wtm1=wtm1*wtmas(i)
            IF(wtm1 .LE. 1d-90) wtm1=0d0
         ELSE
            wtm2=wtm2*wtmas(i)
            IF(wtm2 .LE. 1d-90) wtm2=0d0
         ENDIF
      ENDDO
* Delt1 and eps1 are cutoffs located in YFS formfactor
* Note that xfact=(1+2*qqk/sprim) is EXACTLY the same as in yfs_fin
      qqk  = qq(4)*phsu(4)-qq(3)*phsu(3)-qq(2)*phsu(2)-qq(1)*phsu(1)
      delt1 =  delta*(1+ 2*qqk/sprim)
      eps1  =  sqrt(emin**2/qf1(4)/qf2(4))
* The total phase space integral for crude x-section,
* Note that delta is a lower limit on y-variables in crude generation
      amc2  =  4d0*amfin**2/svar
      betc  =  dsqrt(1d0-amc2)
      fphs  =  2*alf1
     $     *(1d0+betc**2)/(2d0*betc)* dlog((1d0+betc)**2/amc2) 
     $     *dlog(1/delta)
* YFS formfactor cut-off dependend part: 
* delt1 = 2*Emin/sqrt(s'), where Emin is infrared cut-off in QMS
      q1q2= qf1(4)*qf2(4) -qf1(3)*qf2(3) -qf1(2)*qf2(2) -qf1(1)*qf2(1)
      fyfs  = -2d0*alf1
     $     *( q1q2*Aanal(q1q2,amch1,amch2) -1d0 )
     $     *dlog(1/delt1)
      delb  =  fyfs + fphs
* The average mass-weight for removed photon = exp(delb2)
* It can be calculated analyticaly as a  ratio of YFS formfactors
* On the other hand, it is checked by MC, see control weight wtctrl
* Ultrarelativistic (small mass) old version
      delb2u = -2*alf1*(dlog(svar/sprim)+1) *dlog(eps1/delt1)
* Delb2 used actualy
      IF( (amch1+amch2)**2/svar .LT. 1d-5) THEN
         delb2 = delb2u
      ELSE
* Complete delb2 for finite amfin
         delb2 = delb2f(emin,delta,amch1,amch2,qf1,qf2,qf1c,qf2c,phsu)
      ENDIF
* Approximate version of delb2 without A4 function for tests
*      delb2w = -2*alf1*(
*     $     (1d0+betc**2)/(2d0*betc)* dlog((1d0+betc)**2/amc2) 
*     $     -( q1q2*Aanal(q1q2,amch1,amch2) -1d0 )
*     $     ) *dlog(eps1/delt1)
*****[[[[[[*********DEBUG****
*      IF((1-sprim/svar) .gt. 0.01d0) THEN
*         delb2m = delb2f(emin,delta,amch1,amch2,qf1,qf2,qf1c,qf2c,phsu)
*         WRITE(6,'(a,5f20.10)')
*     $  'piatek: ',1-sprim/svar,delb2m,delb2u/delb2m,delb2w/delb2m
*      ENDIF
*****]]]]]]*********DEBUG****
* Control weight - its average should be =1 within statist. error
      wctrl =wtm1*exp(-delb2)
      IF(keypia .EQ. 0) THEN
         IF(abs(delb) .GT. 100d0 ) WRITE(nout,*) ' delb= ',delb
         IF(abs(delb) .GT. 100d0 ) WRITE(   6,*) ' delb= ',delb
         wtrem = 1d0
         wtm3a = wtm1*wtm2*exp(delb)
      ELSE
* Optional removal of photons below epsilon from the record
* in such a case wtm3a includes exp(belb2)= <wt3> for removed ph.
         nph=nphot
         DO j=nphot,1,-1
            IF(phot(j,4) .LT. emin) THEN
               DO i=j+1,nph
                  DO k=1,4
                     phot(i-1,k)=phot(i,k)
                  ENDDO
               ENDDO
               nph=nph-1
            ENDIF
         ENDDO
         nphot=nph
* wtmas includes here average weight of removed photons exp(delb2)
         wtrem = wtm1
         wtm3a = wtm2*exp(delb+delb2)
      ENDIF
      END ! piatek


      SUBROUTINE kinf1(ppz,q1,q2,q1c,q2c,nphot,phot,phsu)
*     ***************************************************
* Transforms to CMS: phot, phsu, q1,q2
* with random Euler rotation in the intermediate ppz frame (Z frame)
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( pi = 3.1415926535897932d0)
      DIMENSION ppz(4),phot(100,4),phsu(4),q1(4),q2(4),q1c(4),q2c(4)
      DIMENSION ph(4),qqk(4),drvec(10)

      IF(nphot .EQ. -1) RETURN
      CALL varran(drvec,2)
      cth= 1.d0 -2.d0*drvec(1)
      the= acos(cth)
      phi= 2.d0*pi*drvec(2)
      DO k=1,4
         qqk(k)=q1(k)+q2(k)+phsu(k)
      ENDDO
      DO i=1,nphot
         DO k=1,4
            ph(k)=phot(i,k)
         ENDDO
         CALL boteul(qqk,ppz,the,phi,ph,ph)
         DO k=1,4
            phot(i,k)= ph(k)
         ENDDO
      ENDDO
      CALL boteul(qqk,ppz,the,phi,q1,q1)
      CALL boteul(qqk,ppz,the,phi,q2,q2)
      CALL boteul(qqk,ppz,the,phi,q1c,q1c)
      CALL boteul(qqk,ppz,the,phi,q2c,q2c)
      CALL boteul(qqk,ppz,the,phi,phsu,phsu)
      END

      SUBROUTINE boteul(qqk,ppz,the,phi,pvec,qvec)
*     *******************************************
* Euler rotation and boosts
      IMPLICIT REAL*8(a-h,o-z)
      REAL*8 pvec(4),qvec(4),qqk(4),ppz(4)

      CALL bostdq( 1,qqk,pvec,qvec)
      CALL rotod1(   the,qvec,qvec)
      CALL rotod3(   phi,qvec,qvec)
      CALL bostdq(-1,ppz,qvec,qvec)
      END


      SUBROUTINE kinf2(qq,am1,am2,q1,q2)
*     ***************************************
* Generates q1, q2 with masses am1,am2, such that qq = q1,q2
* In the qq rest frame spherical density is flat
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( pi = 3.1415926535897932d0)
      DIMENSION qq(*),q1(*),q2(*),drvec(10)

      cmsene= sqrt(qq(4)**2-qq(3)**2-qq(2)**2-qq(1)**2)
      CALL varran(drvec,2)
      cth= 1.d0 -2.d0*drvec(1)
      the= acos(cth)
      phi= 2.d0*pi*drvec(2)
      CALL givpair(cmsene,am1,am2,q1,q2)
      CALL roteul(the,phi,q1,q1)
      CALL bostdq(  -1,qq,q1,q1)
      CALL roteul(the,phi,q2,q2)
      CALL bostdq(  -1,qq,q2,q2)
      END

      SUBROUTINE givpair(cmsene,am1,am2,p1,p2)
*     ****************************************
* For CMS energy = cmsene it defines two "decay" momenta p1,p2
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION p1(*),p2(*)
*
      ener  =  cmsene/2d0
      svar  =  cmsene**2
      beta  =  sqrt((svar-(am1-am2)**2)
     $             *(svar-(am1+am2)**2))/svar
      eta1=    (svar+am1**2-am2**2)/svar
      eta2  =  (svar-am1**2+am2**2)/svar

      p1(1)  =  0d0
      p1(2)  =  0d0
      p1(3)  =  ener*beta
      p1(4)  =  ener*eta1

      p2(1)  =  0d0
      p2(2)  =  0d0
      p2(3)  = -ener*beta
      p2(4)  =  ener*eta2

      END


      SUBROUTINE roteul(the,phi,pvec,qvec)
*     ************************************
* Euler rotation
      IMPLICIT REAL*8(a-h,o-z)
      REAL*8 pvec(4),qvec(4)
      CALL rotod1(the,pvec,qvec)
      CALL rotod3(phi,qvec,qvec)
*======================================================================
*=====================end of karfin part===============================
*======================================================================
      END

      FUNCTION borny(svar1)
*     ********************
* this routine calculates total born cross section.
* it exploits the fact that born x. section = a + b*c + d*c**2
*     ********************
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      svar=svar1
      f0=bornv(svar, 0.d0)
      borny= f0
      END
      FUNCTION bornv(svari,costhe)
*     ***********************************
* this routine provides born differential cross section
* a version without complex*16
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / inout  / ninp,nout
      COMMON / weking / ene,amaz,gammz,amel,amfin,xk0,sinw2,ide,idf
      COMMON / keyyfs / keyzet,keybrm,keyfix,keypia,keywgt
      SAVE / inout  /,/ weking /,/ keyyfs /
*
      IF(abs(costhe) .GT. 1d0) WRITE(nout,*) ' bornv: costhe=',costhe
      qe= -1d0
      qf= -1d0
      aa= 4d0*sqrt(sinw2*(1d0-sinw2))
      ve= (-1d0+4*sinw2)/aa
      ae= 1d0/aa
      IF(keyzet .LE. 0) THEN
        ve=0d0
        ae=0d0
      ENDIF
      vf= (-1d0+4*sinw2)/aa
      af= 1d0/aa
      s = svari
      chi2 =         s**2/((s-amaz**2)**2+(gammz*amaz)**2)
      rechi=(s-amaz**2)*s/((s-amaz**2)**2+(gammz*amaz)**2)
      xe= ve**2 +ae**2
      xf= vf**2 +af**2
      ye= 2*ve*ae
      yf= 2*vf*af
      ff0= qe**2*qf**2 +2*rechi*qe*qf*ve*vf +chi2*xe*xf
      ff1=             +2*rechi*qe*qf*ae*af +chi2*ye*yf
      born    = (1d0+ costhe**2)*ff0 +2d0*costhe*ff1
*************
* this is a bit crude method of introducing threshold behaviour
      IF(    svari .LE.  4d0*amfin**2) THEN
        thresh=0d0
      ELSEIF(svari .LE. 16d0*amfin**2) THEN
        amx2=4d0*amfin**2/svari
        thresh=sqrt(1d0-amx2)*(1d0+amx2/2d0)
      ELSE
        thresh=1d0
      ENDIF
      bornv= born*thresh
      END

      SUBROUTINE poissg(averg,nmax,mult,rr)
*     **************************************
* Last corr. nov. 91
* This generates photon multipl. nphot according to poisson distr.
* Input:  averg = average multiplicity
*         nmax  = maximum multiplicity
* Output: mult = generated multiplicity
*         rr(1:100) list of ordered uniform random numbers,
*         a byproduct result, to be eventually used for some further
*         purpose (i.e.  generation of photon energies).
*     ************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION rr(*)
      COMMON / inout  / ninp,nout
      SAVE
      DATA nfail/0/
*
   50 nn=0
      sum=0d0
      DO it=1,nmax
         CALL varran(rn,1)
         y= log(rn)
         sum=sum+y
         nn=nn+1
         rr(nn)=sum/(-averg)
         IF(sum .LT. -averg) GOTO 130
      ENDDO
      nfail=nfail+1
      IF(nfail .GT. 100) GOTO 900
      GOTO 50
  130 mult=nn-1
      RETURN
  900 WRITE(nout,*) ' poissg: to small nmax'
      STOP
      END

      SUBROUTINE angbre(am2,del1,del2,costhg,sinthg,dist0,dist1)
*     **********************************************************
* This routine generates photon angular distribution
* in the rest frame of the fermion pair.
* The distribution is the S-factor wihtout mass term i.e. 2p_1p_2/(kp_1)(kp_2)
* Fermion mass is treated exactly!
* input:  am2 = 4*massf**2/s where massf is fermion mass
*         and s is effective mass squared of the parent fermion-pair.
* output: costhg, sinthg, cos and sin of the photon
*         angle with respect to fermions direction
*         dist0 = distribution generated, without m**2/(kp)**2 terms
*         dist1 = distribution with m**2/(kp)**2 terms
*     ***************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION rn(10)

      CALL varran(rn,2)
      beta =sqrt(1.d0-am2)
      eps  =am2/(1.d0+beta)                     != 1-beta
      del1 =(2.d0-eps)*(eps/(2.d0-eps))**rn(1)  != 1-beta*costhg
      del2 =2.d0-del1                           != 1+beta*costhg
* calculation of sin and cos theta from internal variables
      costhg=(del2-del1)/(2*beta)               ! exact
      sinthg=sqrt(del1*del2-am2*costhg**2)      ! exact
* symmetrization
      IF(rn(2) .LE. 0.5d0) THEN
        a=del1
        del1=del2
        del2=a
        costhg= -costhg
      ENDIF
      dist0=1d0/(del1*del2)*(1d0 -am2/2d0)
      dist1=1d0/(del1*del2) 
     $     *(1d0 -am2/2d0 -am2/4d0*(del1/del2+del2/del1))
* totaly equivalent formula is the following
*     dist1=1d0/(del1*del2)   *beta*sinthg**2/(del1*del2)
      END

      SUBROUTINE dumps(nout)
*     **********************
* This prints out ALL four momenta on unit no. nout
*     **********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / momset / qf1(4),qf2(4),sphum(4),sphot(100,4),nphot
      SAVE   / momset /
      DIMENSION sum(4)
      WRITE(nout,*) '=============ALL====MOMSET===================='
      WRITE(nout,3100) 'qf1',(  qf1(  k),k=1,4)
      WRITE(nout,3100) 'qf2',(  qf2(  k),k=1,4)
      DO i=1,nphot
         WRITE(nout,3100) 'pho',(sphot(i,j),j=1,4)
      ENDDO
      DO k=1,4
         sum(k)=qf1(k)+qf2(k)
      ENDDO
      DO i=1,nphot
         DO k=1,4
            sum(k)=sum(k)+sphot(i,k)
         ENDDO
      ENDDO
      WRITE(nout,3100) 'sum',(  sum(  j),j=1,4)
 3100 FORMAT(1x,a3,1x,5f20.14)
      END

      SUBROUTINE dumpf(nout)
*     **********************
* This prints out four momenta of FSR photons on unit no. nout
*     **********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / momfin / qf1(4),qf2(4),sphum(4),sphot(100,4),nphot
      SAVE   / momfin /
      DIMENSION sum(4)
      WRITE(nout,*) '============FSR=====MOMFIN===================='
      WRITE(nout,3100) 'qf1',(  qf1(  k),k=1,4)
      WRITE(nout,3100) 'qf2',(  qf2(  k),k=1,4)
      DO i=1,nphot
         WRITE(nout,3100) 'pho',(sphot(i,k),k=1,4)
      ENDDO
      DO k=1,4
         sum(k)=qf1(k)+qf2(k)
      ENDDO
      DO i=1,nphot
         DO k=1,4
            sum(k)=sum(k)+sphot(i,k)
         ENDDO
      ENDDO
      WRITE(nout,3100) 'sum',(  sum(  k),k=1,4)
 3100 FORMAT(1x,a3,1x,5f20.14)
      END

      SUBROUTINE dumpi(nout)
*     **********************
* This prints out four momenta of ISR photons on unit no. nout
*     **********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / momini / qf1(4),qf2(4),sphum(4),sphot(100,4),nphot
      SAVE   / momini /
      DIMENSION sum(4)
      WRITE(nout,*) '============ISR=====MOMINI===================='
      WRITE(nout,3100) 'qf1',(  qf1(  k),k=1,4)
      WRITE(nout,3100) 'qf2',(  qf2(  k),k=1,4)
      DO i=1,nphot
         WRITE(nout,3100) 'pho',(sphot(i,k),k=1,4)
      ENDDO
      DO k=1,4
         sum(k)=qf1(k)+qf2(k)
      ENDDO
      DO i=1,nphot
         DO k=1,4
            sum(k)=sum(k)+sphot(i,k)
         ENDDO
      ENDDO
      WRITE(nout,3100) 'sum',(  sum(  k),k=1,4)
 3100 FORMAT(1x,a3,1x,5f20.14)
      END

      SUBROUTINE dumpn(nout,iev)
*     **************************
* this prints out four momenta of final state
* and the serial number of event iev on unit nout
*     **********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      COMMON / momini / qf1(4),qf2(4),sphum(4),sphot(100,4),nphot
      SAVE   / momini /
      DIMENSION sum(4)
      WRITE(nout,*) '======ISR=====MOMINI====================>',iev
      WRITE(nout,3100) 'qf1',(  qf1(  k),k=1,4)
      WRITE(nout,3100) 'qf2',(  qf2(  k),k=1,4)
      DO i=1,nphot
         WRITE(nout,3100) 'pho',(sphot(i,k),k=1,4)
      ENDDO
      DO k=1,4
         sum(k)=qf1(k)+qf2(k)
      ENDDO
      DO i=1,nphot
         DO k=1,4
            sum(k)=sum(k)+sphot(i,k)
         ENDDO
      ENDDO
      WRITE(nout,3100) 'sum',(  sum(  k),k=1,4)
 3100 FORMAT(1x,a3,1x,5f20.14)
      END

      SUBROUTINE wform(cmsene,q1,q2,amf,delta,eps,dyfs)
*     *************************************************
* Unused, kept for some future tests, small mass approx.
* Yennie-Fraytschi-Suura formfactors for the final state ferm. pair
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER(pi=3.1415926535897932d0,alfinv=137.03604d0)
      PARAMETER(alf1=1/alfinv/pi)
      DIMENSION q1(4),q2(4)

      svar  = cmsene**2
      ene= cmsene/2
* momenta q1,q2 should be in cms
      e1 = q1(4)
      e2 = q2(4)
      gamf2 = 2*alf1* dlog(svar /amf**2)
      delb  = gamf2*dlog(ene/sqrt(e1*e2)*eps/delta)
      ep    = e1+e2
      em    = e1-e2
      q1q2  = q1(4)*q2(4)-q1(3)*q2(3)-q1(2)*q2(2)-q1(1)*q2(1)
      dl    = sqrt( 2*q1q2 +em**2 )
      remn  = pi**2/2
     $        -0.50*dlog(e1/e2)**2
     $        -0.25*dlog((dl+em)**2/(4*e1*e2))**2
     $        -0.25*dlog((dl-em)**2/(4*e1*e2))**2
     $        - dilogy((dl+ep)/(dl+em)) -dilogy((dl-ep)/(dl-em))
     $        - dilogy((dl-ep)/(dl+em)) -dilogy((dl+ep)/(dl-em))
      dyfs  = exp( delb +alf1*remn )
      END
