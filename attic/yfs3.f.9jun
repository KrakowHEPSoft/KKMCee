* tobedone:
* clean-up yfslib
*
      SUBROUTINE yfs3ff(mode,xpar,ypar)
*     *********************************
*=======================================================================
*=======================================================================
*=============================YFS3ff====================================
*=====================FERMION PAIR PRODUCTION===========================
*===============INITIAL AND FINAL STATE EXPONENTIATION==================
*=======================================================================
*=======================================================================
*=======================YFS VERSION 3.4.0===============================
*=======================================================================
*======================= September 1987 ================================
*======================= February  1993 ================================
*======================= May       1997 ================================
*=======================================================================
* AUTHORS:
*    S. Jadach, Institute of Nuclear Physics, Cracow, Poland
*    B.F.L. Ward, University of Tennessee, Knoxville, Tennessee
*=======================================================================
*
* some controll histograming still in PROGRAM
*
* generator of Yennie-Frautschi-Suura type
* with exponentiated single bremsstrahlung
********** input
* mode =-1/0/1/2 defines
*       initialization/generation/give-xsection/final-report
********** output
* fourmomenta and photon multiplicity in /momset/
* ypar(10)=xsecnb = cross section in nanobarns
* ypar(11)=errel  = relative error (dimensionless)
* ypar(12)=xsmc   = cross section in r-units
***************************
* for advanced users only:
* (1) one may use KeyBrm < 0  for running at fixed v-variable,
* in this case all events have  v=vmax precisely.
* (2) for KeyWgt=1 weighted events are generated and the user should
* use the weight wtyfs from ypar(201)
* wtyfs is the actual model weight depending on other input params.
* the other interesting possibility is to use
*     wt=wtcru1*wtcru2*wtset(i) where
*     wtset(71) =   zero-th order initial+final
*     wtset(72) =   first order   initial+final
*     wtset(73) =   second order  initial+final
* and the following provide the corresponding components of x-section.
*     wtset(80) =   first order, beta0 contribution alone
*     wtset(81) =   first order, beta1 contribution alone
*     wtset(90) =   second order, beta0 contribution alone
*     wtset(91) =   second order, beta1 contribution alone
*     wtset(92) =   second order, beta2 contribution alone
* furthermore, for the initial state alone we provide
*     wtset( 1) =   zero-th order initial
*     wtset( 2) =   first order   initial
*     wtset( 3) =   second order  initial
* and the corresponding components
*     wtset(20) =   first order, beta0 contribution alone
*     wtset(29) =   first order, beta1 contribution alone
*     wtset(30) =   second order, beta0 contribution alone
*     wtset(31) =   second order, beta1 contribution alone
*     wtset(32) =   second order, beta2 contribution alone
*     ************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( pi=3.1415926535897932d0,alfinv=137.03604d0)
      DIMENSION  xpar( *),ypar( *)
* BoX-FORMATs for nice and flexible outputs
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      PARAMETER (
     $  bxope ='(//1x,15(5h*****)    )',
     $  bxtxt ='(1x,1h*,                  a48,25x,    1h*)',
     $  bxl1i ='(1x,1h*,i17,                 16x, a20,a12,a7, 1x,1h*)',
     $  bxl1f ='(1x,1h*,f17.8,               16x, a20,a12,a7, 1x,1h*)',
     $  bxl2f ='(1x,1h*,f17.8, 4h  +-, f11.8, 1x, a20,a12,a7, 1x,1h*)',
     $  bxl1g ='(1x,1h*,g17.8,               16x, a20,a12,a7, 1x,1h*)',
     $  bxl2g ='(1x,1h*,g17.8, 4h  +-, f11.8, 1x, a20,a12,a7, 1x,1h*)',
     $  bxclo ='(1x,15(5h*****)/   )'
     $ )

* Global commnon block, input/output unit numbers
      COMMON / inout  / ninp,nout
* Dedicated commnon block for communication with gmonit routine
      COMMON / cmonit/ averwt,errela,nevtot,nevacc,nevneg,nevove,nevzer
* Dedicated common for communication with varran
      COMMON / ranpar / keyrnd

      DIMENSION wtset(100)
      DIMENSION xf1(4),xf2(4),xphum(4),xphot(100,4)
      DIMENSION yf1(4),yf2(4),yphum(4),yphot(100,4)
      DIMENSION pf1(4),pf2(4),qf1(4),qf2(4),sphum(4),sphot(100,4)
      DIMENSION xxf(4),yyf(4)
      DIMENSION yini(100),zini(100),yfin(100),zfin(100)
      SAVE

      IF(mode .EQ. -1) THEN
*     ==================================================================
*     =====================initialization===============================
*     ==================================================================

 6900 FORMAT('1',10(/,10x,a))
      WRITE(nout,6900)
     $'  *************************************************************',
     $'  *  ****   ****  **********    *******          ***********  *',
     $'  *  ****   ****  **********  **********         **********   *',
     $'  *   **** ****   ****        *****                 ******    *',
     $'  *    ******     ********      ******    *****    ******     *',
     $'  *     ****      ********         *****  *****      ******   *',
     $'  *     ****      ****        **********         ***********  *',
     $'  *     ****      ****         *******           **********   *',
     $'  *************************************************************',
     $' '

!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
*
      cmsene = xpar(1)
*
      KeyWgt = xpar(10)
      KeyFix = xpar(25)
      KeyPia = xpar(22)
*
      amaz   = xpar(502)
      sinw2  = xpar(503)
      gammz  = xpar(504)
      KeyZet = xpar(501)

      KFbeam = 11           ! KF=11 is electron
      ke = 500+10*KFbeam
      amel   = xpar(ke+6)
*
* Muon mass sets absolute maximum for vvmax
* M.C. algorithm in yfs_ini cannot support lower masses
      KFfin = 13
      amfin  = xpar(500+10*KFfin+6)
*
* ISR infrared cu-off
      vvmin  = xpar(16)
* xpar(17)--> ypar(17) is corrected if necessary !!!
      vvmax  = xpar(17)
      vvmax  = min(vvmax,1d0-(2*amfin/cmsene)**2)
      ypar(17) = vvmax
      delfac = xpar(18)
* FSR infrared cut-off, smaller then vvmin
      delta  = vvmin*delfac
**
* The type of the random number generator ranmar
      keyrnd = 1
*
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) '    YFS3 version 3.40   May.1997      '
      WRITE(nout,bxl1f) cmsene,     'cms energy total   ','cmsene','a0'
      WRITE(nout,bxl1f) amfin,      'final fermionmass  ','amfin ','a2'
      WRITE(nout,bxl1f) amaz,       'Z mass   [gev]     ','amaz  ','a3'
      WRITE(nout,bxl1f) gammz,      'Z width  [gev]     ','gammz ','a4'
      WRITE(nout,bxl1f) sinw2,      'sin(theta_w)**2    ','sinw2 ','a5'
      WRITE(nout,bxl1f) vvmin,      'dummy infrared cut ','vvmin ','a6'
      WRITE(nout,bxl1f) vvmax,      'v_max ( =1 )       ','vvmax ','a7'
      WRITE(nout,bxl1i) KeyPia,     'removal    switch  ','KeyPia','a8'
      WRITE(nout,bxl1i) KeyWgt,     'weighting  switch  ','KeyWgt','a9'
      WRITE(nout,bxl1i) KeyZet,     'elect_weak switch  ','KeyZet','a10'
      WRITE(nout,bxclo)
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
! Identificator for this generator
      idgen = 6
! Important histo which remembers total x-section
      CALL gmonit(  -1, idgen,1d0,1d0,1d0)
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
!= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =
*     gmonit monitors weights
      idyfs = 0
      CALL gmonit(-1,idyfs+71,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+72,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+73,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+74,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+75,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+78,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+79,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+80,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+81,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+90,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+91,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+92,0d0,1d0,1d0)
      CALL gbook1(idyfs +5,'wt yfs3    nphot.ne.0  $', 60 ,-1d0, 5d0)
      CALL gbook1(idyfs+11,'photon multiplicity    $', 50,  0d0,50d0)
*

      CALL KarLud(-1,xpar,ypar,
     $     pf1,pf2,xxf,xf1,xf2,         ! output
     $     nphox,xphot,xphum,yini,zini) ! output
      xcru = ypar(3)

* normalization in nanobarns
      gnanob=389.385d-30*1.d33
      sig0nb =  4d0*pi/(alfinv**2*3d0*cmsene**2)*gnanob
      xcrunb = xcru*sig0nb
*
      CALL karfin(-1,xpar,ypar,
     $     xxf,
     $     yf1,yf2,nphoy,yphot,yphum,yfin,zfin,wt)
*
      nevgen=0

      ELSEIF(mode  .EQ.  0) THEN
*     ==================================================================
*     =====================generation===================================
*     ==================================================================
      nevgen=nevgen+1
  100 CONTINUE
      LevPri =xpar( 5)  !PrintOut Level 0,1,2,3
      Ie1Pri =xpar( 6)  !PrintOut Start point
      Ie2Pri =xpar( 7)  !PrintOut End   point
* =============================================
*     ISR
* =============================================
* define pf1,2, xxf and xf1,2
* Final state masses may be now different (for W pair production)
      CALL KarLud( 0,xpar,ypar,
     $     pf1,pf2,xxf,xf1,xf2,
     $     nphox,xphot,xphum,yini,zini)
      wtkarl = ypar(2)
      KFfin  = ypar(400)
*   Control printout
      IF(LevPri .GE. 2) CALL dumpri(' KarLud ',
     $     nout,nevgen,Ie1Pri,Ie2Pri,xf1,xf2,nphox,xphot)
* =============================================
*     FSR
* =============================================
* define yf1,2 and yyf
* Final state momenta in the xxf frame (Z-frame)
* Initialize momenta to zero
      DO k=1,4
         yf1(k)=0d0
         yf2(k)=0d0
         yphum(k)=0d0
      ENDDO
      nphoy=0
      DO j=1,100
         DO k=1,4
            yphot(j,k)=0d0
         ENDDO
      ENDDO
* Generate FSR photons and final fermion momenta
      IF(wtkarl .NE. 0d0) THEN
         CALL karfin(0,xpar,ypar,
     $        xxf,
     $        yf1,yf2,nphoy,yphot,yphum,yfin,zfin,wtcfin)
*
         DO k=1,4
            yyf(k) = yf1(k)+yf2(k)
         ENDDO
      ENDIF
*   Control printout
      IF(LevPri .GE. 2) CALL dumpri('  KarFin ',
     $     nout,nevgen,Ie1Pri,Ie2Pri,yf1,yf2,nphoy,yphot)
* =============================================
* Merging momenta and transform to CMS frame
* At the moment it is of litle use, only for control printout below
* =============================================
* FSR photons appended behind ISR photons
      nphot  = 0
      DO i=1,nphox
         nphot  =nphot+1
         DO k=1,4
            sphot(nphot,k)=xphot(i,k)
         ENDDO
      ENDDO
      DO  i=1,nphoy
         nphot  =nphot+1
         DO  k=1,4
            sphot(nphot,k)=yphot(i,k)
         ENDDO
      ENDDO
* final state fermions
      DO k=1,4
         qf1(k)= yf1(k)
         qf2(k)= yf2(k)
      ENDDO
* axiliary
      DO k=1,4
         sphum(k)= xphum(k)+yphum(k)
      ENDDO
* =============================================
*   Control printout
      IF(LevPri .GE. 1) CALL  momprt(' YFS3ff ',
     $     nout,nevgen,Ie1Pri,Ie2Pri,pf1,pf2,qf1,qf2,nphot,sphot,KFfin)
* =================== all kinematics is fixed at this point =======
      wtcru1 = wtkarl
      wtcru2 = wtcfin
      wtcrud = wtkarl*wtcfin
* =================== all weights are fixed at this point =========
* Model weight
* Note that matrix element exploits xphot, yphot
      wtmax=2.5d0
      CALL model(wtcrud,xpar,ypar,
     $     pf1,pf2,xxf,yf1,yf2,
     $     nphox,xphot,yini,zini,
     $     nphoy,yphot,yfin,zfin,
     $     wtbest,wtset)
* principal model weight for wt=1 events (after rejection)
      wt     = wtcrud*wtbest
* weight monitoring
      CALL gmonit(0,idyfs+73,wtcrud*wtset(73),wtmax,0d0)
      CALL gmonit(0,idyfs+72,wtcrud*wtset(72),wtmax,0d0)
      CALL gmonit(0,idyfs+71,wtcrud*wtset(71),wtmax,0d0)
      CALL gmonit(0,idyfs+75,wtcrud*(wtset(73)-wtset(72)),wtmax,0d0)
      CALL gmonit(0,idyfs+74,wtcrud*(wtset(72)-wtset(71)),wtmax,0d0)
      CALL gmonit(0,idyfs+80,wtcrud*wtset(80),wtmax,0d0)
      CALL gmonit(0,idyfs+81,wtcrud*wtset(81),wtmax,0d0)
      CALL gmonit(0,idyfs+90,wtcrud*wtset(90),wtmax,0d0)
      CALL gmonit(0,idyfs+91,wtcrud*wtset(91),wtmax,0d0)
      CALL gmonit(0,idyfs+92,wtcrud*wtset(92),wtmax,0d0)
* test histograms
      xmult=float(nphot)+.1d0
      CALL gf1(idyfs+11,xmult,1d0)
      IF(nphot .GE. 0) CALL gf1(idyfs+5,wt,1d0)
* =============================================
* Optional rejection according to principal weight
      IF(KeyWgt .EQ. 0) THEN
         CALL gmonit(0, idgen, xcrunb*wtmax, wtmax, 1d0)
* constant-weight events with wt=1
         CALL varran(rn,1)
         CALL gmonit(0,idyfs+79,wt ,wtmax,rn)
         IF(rn  .GT.  wt/wtmax) GOTO 100
         wtyfs=1.d0
* wtcru1,2  weights are reset to one
         wtcru1=1d0
         wtcru2=1d0
* wtset reset to zero
         DO j=1,100
            wtset(j) =0d0
         ENDDO
      ELSE
* variable-weight events
         wtyfs  = wtcrud*wtbest
         CALL gmonit(0,idgen,   xcrunb ,wtmax,1d0)
         CALL gmonit(0,idyfs+79,wtyfs  ,wtmax,0d0)
         CALL gmonit(0,idyfs+78,wtcrud ,wtmax,0d0)
      ENDIF
* =============================================
* collection of the weights
         DO j=1,100
            ypar(100+j)=wtset(j)
         ENDDO
         ypar(201)=wtyfs
         ypar(202)=wtcrud
         ypar(203)=wtcru1
         ypar(204)=wtcru2
* =============================================
*   Fill standard HEP and/or LUND common blocks
*   For wt=0 events qf1,2 are set to zero (no hadronization in tohad)
      CALL tohep( xpar,ypar,pf1,pf2,yf1,yf2,xphot,nphox,yphot,nphoy)
      CALL tohad( xpar,ypar)
* =============================================


      ELSEIF(mode .EQ. 1 .OR. mode .EQ. 2) THEN
*     ==================================================================
*     =====================final weight analysis========================
*     ==================================================================
      xbornb =  borny(0d0,xpar,ypar)*sig0nb
      CALL KarLud(mode,xpar,ypar,
     $     pf1,pf2,xxf,xf1,xf2,
     $     nphox,xphot,xphum,yini,zini)
      xkarl = ypar(3)
      erkarl = 0d0
*
      CALL karfin(mode,xpar,ypar,
     $     xxf,
     $     yf1,yf2,nphoy,yphot,yphum,yfin,zfin,wt)
*
      CALL gmonit(1,idyfs+79,dumm1,dumm2,dumm3)
      ypar(10)= nevgen
      xsmc   =  xkarl*averwt
      erel   =  sqrt(erkarl**2+errela**2)
      erabs  =  xsmc*erel
      xsmcnb =  xsmc*sig0nb
      erabs2 =  xsmcnb*erel
      ypar(10)= xsmcnb
      ypar(11)= erel
      ypar(12)= xsmc
      IF(KeyWgt .EQ. 0) THEN
* weighted events, normal option
         ypar(20)=xsmcnb
         ypar(21)=erel
         ypar(22)=xsmc
      ELSE
* weighted events, additional information on x-sections
         CALL gmonit(1,idyfs+78,dumm1,dumm2,dumm3)
         ypar(20)= xkarl*sig0nb
         ypar(21)= errela
         ypar(22)= xkarl
      ENDIF
* no printout for mode =1
      IF(mode .EQ. 1) RETURN
*[[[    CALL gprint(idyfs+11)
      CALL gprint(idyfs+ 5)
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) '  yfs3  output - window a'
      WRITE(nout,bxl1f) cmsene,     'cms energy total   ','cmsene','a0'
      WRITE(nout,bxl2f) xsmc,erabs, 'xs_tot mc r-units  ','xsmc  ','a1'
      WRITE(nout,bxl1f) xsmcnb,     'xs_tot    nanob.   ','xsmcnb','a3'
      WRITE(nout,bxl1f) erabs2,     'absolute error     ','erabs2','a4'
      WRITE(nout,bxl1f) erel,       'relative error     ','erel  ','a5'
      WRITE(nout,bxl1i) nevtot,     'total no of events ','nevtot','a6'
      WRITE(nout,bxl1i) nevacc,     'accepted    events ','nevacc','a7'
      WRITE(nout,bxl1i) nevneg,     'wt<0        events ','nevneg','a8'
      WRITE(nout,bxl1i) nevove,     'wt>wtmax    events ','nevove','a9'
      WRITE(nout,bxl1f) wtmax ,     'wtmax              ','wtmax ','a10'
      WRITE(nout,bxl1f) xbornb,     'xs_born   nanob.   ','xbornb','a11'
      WRITE(nout,bxclo)
*     ==================================================================
*     =============suppl. final weight analysis=========================
*     ==================================================================
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) '        yfs3   output - window b '
      WRITE(nout,bxtxt) '           x-sections in r-units '
      CALL gmonit(1,idyfs+73,dumm1,dumm2,dumm3)
      xs03   =  xkarl*averwt
      dxs03  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      CALL gmonit(1,idyfs+72,dumm1,dumm2,dumm3)
      xs02   =  xkarl*averwt
      dxs02  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      CALL gmonit(1,idyfs+71,dumm1,dumm2,dumm3)
      xs01   =  xkarl*averwt
      dxs01  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      CALL gmonit(1,idyfs+75,dumm1,dumm2,dumm3)
      xs05   =  xkarl*averwt
      dxs05  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      CALL gmonit(1,idyfs+74,dumm1,dumm2,dumm3)
      xs04   =  xkarl*averwt
      dxs04  =  xkarl*averwt*sqrt(erkarl**2+errela**2)
      WRITE(nout,bxl2f) xs03,dxs03,'x-section','o(alf2)',  'b1'
      WRITE(nout,bxl2f) xs02,dxs02,'x-section','o(alf1)',  'b2'
      WRITE(nout,bxl2f) xs01,dxs01,'x-section','o(alf0)',  'b3'
      IF(xs02.ne.0d0) WRITE(nout,bxl2f)
     $ xs05/xs02,dxs05/xs02,'(o(alf2)-o(alf1))','/o(alf1)','b4'
      IF(xs01.ne.0d0) WRITE(nout,bxl2f)
     $ xs04/xs01,dxs04/xs01,'(o(alf1)-o(alf0))','/o(alf0)','b5'
      WRITE(nout,bxclo)
* -------------
      wtcru1 = xkarl
      wtcru2 = erkarl
* -------------
      ELSE
*     ====
      WRITE(nout,*) '===>yfs3: wrong mode'
      STOP
      ENDIF
*     =====
      END


      SUBROUTINE KarLud(mode,xpar,ypar,
     $     pf1,pf2,qq,qf1,qf2,                   ! output
     $     nphot,sphot,sphum,yini,zini)          ! output
*     ********************************************************
* Top level  Monte-Carlo event generator for ISR radiadion.
* Administrates directly generation of v-variable
* and indirectly of all other variables.
*     ************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER (nmax= 40)
      DIMENSION xpar(*),ypar(*)
* BoX-FORMATs for nice and flexible outputs
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      PARAMETER (
     $  bxope ='(//1x,15(5h*****)    )',
     $  bxtxt ='(1x,1h*,                  a48,25x,    1h*)',
     $  bxl1i ='(1x,1h*,i17,                 16x, a20,a12,a7, 1x,1h*)',
     $  bxl1f ='(1x,1h*,f17.8,               16x, a20,a12,a7, 1x,1h*)',
     $  bxl2f ='(1x,1h*,f17.8, 4h  +-, f11.8, 1x, a20,a12,a7, 1x,1h*)',
     $  bxl1g ='(1x,1h*,g17.8,               16x, a20,a12,a7, 1x,1h*)',
     $  bxl2g ='(1x,1h*,g17.8, 4h  +-, f11.8, 1x, a20,a12,a7, 1x,1h*)',
     $  bxclo ='(1x,15(5h*****)/   )'
     $ )
      COMMON / inout  / ninp,nout
* communicates with gmonit
      COMMON / cmonit/ averwt,errela,nevtot,nevacc,nevneg,nevove,nevzer
*
      DIMENSION qf1(4),qf2(4),sphum(4),sphot(100,4),yini(100),zini(100)
      DIMENSION pf1(4),pf2(4),qq(4)
      SAVE
      EXTERNAL rhosko
*
      IF(mode .EQ. -1) THEN
*     ==================================================================
*     ===================initialization=================================
*     ==================================================================
      nevgen = 0
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'initialize KarLud  start'
*
      idyfs = 0
      CALL gbook1(idyfs+ 7,'wt in KarLud         $', 50 , 0d0,5d0)
      CALL gmonit(-1,idyfs+59,0d0,1d0,1d0)
*
* Input parameters:
      cmsene = xpar( 1)

      KFbeam = 11           ! KF=11 is electron
      ke = 500+10*KFbeam
      amel   = xpar(ke+6)

      vvmin  = xpar(16)
      vvmax  = ypar(17)
*
      KeyZet = xpar(501)
      KeyISR = xpar(20)
      KeyFix = xpar(25)
      xborn  = borny(0d0,xpar,ypar)
*
      IF(KeyISR .EQ. 1) THEN
         CALL vesko1(-1,rhosko,xpar,ypar)
         xcvesk = ypar(3)
         crude  = ypar(3)
*     Miscelaneous x-check on x-section from vesko1
         prec   = xborn*1d-5
         a = 0d0
         b = 1d0
         CALL gausjad(rhosko,xpar,ypar,a,b,prec,result)
         xcgaus = result
         xdel = xcvesk/xcgaus-1
         WRITE(nout,bxl1f) xcvesk,'xs_crude  vesko    ','xcvesk','  '
         WRITE(nout,bxl1f) xcgaus,'xs_crude  gauss    ','xcgaus','  '
         WRITE(nout,bxl1f) xdel  ,'xcvesk/xcgaus-1    ','      ','  '
      ELSEIF(KeyISR .EQ. 0) THEN
         ypar(3) = xborn
         WRITE(nout,bxl1f) xcvesk,'xs_crude  Born     ','xborn ','  '
      ELSE
         WRITE(*,*) ' ++++ KarLud: wrong KeyISR=',KeyISR
         STOP
      ENDIF
*
      WRITE(nout,bxtxt) 'initialize KarLud  ENDed'
      WRITE(nout,bxclo)
*
      ELSEIF(mode .EQ. 0) THEN
*     ==================================================================
*     ====================generation====================================
*     ==================================================================
   30 CONTINUE
      nevgen = nevgen+1
      IF(KeyISR .EQ. 1) THEN
*-------------------------------------------------------------
*     Generate vv = 1-s'/s
         IF(KeyFix .EQ. 0) THEN
            CALL vesko1( 0,rhosko,xpar,ypar)
            wtves = ypar(3)
            vv    = ypar(10)
         ELSE
            wtves=1d0
            vv=vvmax
         ENDIF
*        Low-level multiphoton generator
         MltISR =  xpar(23)
         CALL yfs_ini(MltISR,cmsene,amel,vv,vvmin,nmax,
     $        pf1,pf2,nphot,sphot,sphum,yini,zini,qq,wtISR)
*
         wtkarl=wtves*wtISR
*-------------------------------------------------------------
      ELSEIF(KeyISR .EQ. 0) THEN
         CALL givpair(cmsene,amel,amel,pf1,pf2,bt1,et1,et2)
         DO k=1,4
            qq(k) = pf1(k)+pf2(k)
         ENDDO
         nphot   = 0
         wtkarl  = 1d0
      ELSE
         WRITE(*,*) ' ++++ KarLud: wrong KeyISR=',KeyISR
         STOP
      ENDIF
*-------------------------------------------------------------
      IF(wtkarl .EQ. 0d0 ) THEN
*     Set momenta to zero for WT=0 events
         DO k=1,4
            qf1(k)=0d0
            qf2(k)=0d0
            sphum(k)=0d0
         ENDDO
         nphot=0
         DO j=1,100
            DO k=1,4
               sphot(j,k)=0d0
            ENDDO
         ENDDO
         ypar(400)=0d0
      ELSE
*     Generation of the flavour KF
         CALL defKF(xpar,ypar)
         KFfin=ypar(400)
         kf = 500+10*KFfin
*     Define final fermion momenta (NOT used in case of FSR)
*     qq is the four-momentum of final state fermion pair in CMS
         amfi1  = xpar(kf+6)
         amfi2  = xpar(kf+6)
         CALL phspc2( qq,amfi1,amfi2,qf1,qf2,wtt)
      ENDIF
*-------------------------------------------------------------
*     Final administration
      ypar(2) = wtkarl
      CALL gmonit(0,idyfs+59,wtkarl,  1d0,1d0)
      CALL gf1(idyfs+ 7,wtkarl,1d0)
* =============================================
*
      ELSE
*     ==================================================================
*     ====================final weight analysis=========================
*     ==================================================================
      IF(mode .EQ. 2) CALL gprint(idyfs+ 7)
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) '     KarLud  final  report     '
      WRITE(nout,bxtxt) '         window a              '

      IF(KeyISR .EQ. 1) THEN
         CALL gmonit(1,idyfs+59,dumm1,dumm2,dumm3)
         wtkarl = averwt
         erkrl  = errela
         CALL vesko1( 1,rhosko,xpar,ypar)
         xsve   = ypar(1)
         erelve = ypar(2)
         xcvesk = ypar(3)
         erve   = xsve*erelve
         IF(KeyFix .EQ. 1)  xcvesk=xcgaus
         crude   = xcvesk
*     no printout for mode = 1
         IF(mode .EQ. 2) THEN
            WRITE(nout,bxl1i) nevtot,'total no of events ','nevtot','a0'
            WRITE(nout,bxl1i) nevneg,'wt<0        events ','nevneg','a1'
            WRITE(nout,bxl1f) xcvesk,'xs_cru vesko  [R]  ','xcvesk','a2'
            WRITE(nout,bxl2f) 
     $           xsve,erve,  'xs_est vesko  [R]  ','xsve  ','a3'
            WRITE(nout,bxl2f) 
     $           xcgaus,prec,'xs_est gauss  [R]  ','xcgaus','a4'
            ddv    = xsve/xcgaus-1d0
            ddr    = erelve + 1d-6
            xskr   = xcvesk*wtkarl
            erkr   = xskr*erkrl
            WRITE(nout,bxl2f) 
     $           ddv,ddr,    'xcve/xcgs-1        ','      ','a5'
            WRITE(nout,bxl2f)
     $           wtkarl,erkrl,'   <wt>           ','wtkarl','a6'
            WRITE(nout,bxl2f) 
     $           xskr,erkr,  'sigma_prim    [R]  ','xskarl','a7'
         ENDIF
      ELSEIF(KeyISR .EQ. 0) THEN
         IF(mode .EQ. 2) THEN
            WRITE(nout,bxl1i) nevtot,'total no of events ','nevtot','a0'
            WRITE(nout,bxl1f) xcvesk,'xs_crude  Born     ','xborn ','  '
         ENDIF
      ELSE
         WRITE(*,*) ' ++++ KarLud: wrong KeyISR=',KeyISR
         STOP
      ENDIF
*
      WRITE(nout,bxclo)
*
      ENDIF
*     =====
      END

      SUBROUTINE defKF(xpar,ypar)
*     ******************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION xpar(*),ypar(*)
      DIMENSION cumuKF(20)
      DIMENSION drvec(10)
      SAVE

      CALL varran(drvec,1)
      rnumb = drvec(1)
      sum=0d0
      DO i=1,20
         sum = sum +ypar(400+i)
         cumuKF(i)= sum
      ENDDO
      IF(sum .EQ. 0d0 ) GOTO 900
      DO i=1,20
         cumuKF(i)=cumuKF(i)/sum
c         write(*,*) 'i,cumuKF(i)=',i,cumuKF(i)
      ENDDO

      DO i=1,20
         IF(rnumb .LE. cumuKF(i)) THEN
            KFfin=xpar(400+i)
c            write(*,*) 'rnumb,i,KFfin=',rnumb,i,KFfin
            GOTO 500
         ENDIF
      ENDDO
      write(*,*) '+++ defKF: STOP, unable to define KF'
      STOP
 500  CONTINUE
      ypar(400) =  KFfin
      RETURN
*
 900  CONTINUE
      write(*,*) '+++ defKF: STOP, sum=0'
      STOP
      END


      FUNCTION rhosko(r,xpar,ypar)
*     ****************************
* Called in vesko1 (generation of vv) and KarLud (Gauss integration).
* Provides vv distribution to be generated
*     ********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER (pi =3.1415926535897932d0, alfinv= 137.03604d0)
      PARAMETER (alf1 = 1d0/pi/alfinv)
      PARAMETER (fleps = 1d-35)
      DIMENSION xpar(*),ypar(*)
      SAVE

      cmsene = xpar( 1)

      KFbeam = 11           ! KF=11 is electron
      ke = 500+10*KFbeam
      amel   = xpar(ke+6)

      KeyZet = xpar(501)
      svar   = cmsene**2
      vvmin  = xpar(16)
      vvmax  = ypar(17)
*
* Mapping  r => vv change  to improve on efficiency
* Note that the replacement below makes program more precise
* and bullet-proof with respect numerical instabilities close to vv=0
      bilg   = dlog(svar/amel**2)
      gami   = 2d0*alf1*(bilg-1d0)
      gami2  = 2d0*alf1*bilg
      x = max(r,fleps**gami)
      bbt = -0.5d0
      CALL chbin1(x,gami,bbt,vvmax,vv,rjac)
* Born x-section at s'=svar1
      svar1  = svar*(1d0-vv)
      IF(KeyZet .EQ. -2) THEN
*     Artificial constant x-section for test runs
         xborn = borny(0d0,xpar,ypar)
      ELSE
* Note presence of 1/(1-vv) because borny is in R-units
         xborn  = borny(vv,xpar,ypar)/(1d0-vv)
      ENDIF
      IF(vv .GT. vvmin) THEN
         dilat=(1d0+1d0/sqrt(1d0-vv))/2d0
         damel=gami2/gami*(vv/vvmin)**(gami2-gami)
      ELSE
         dilat=1d0
         damel=1d0
      ENDIF
      rho= gami*vv**(gami-1d0)*dilat*damel
      rhosko = rjac*xborn* rho
*
      ypar(10) = vv
*
      END


      SUBROUTINE yfs_ini(MltISR,cmsene,amel,vv,vmin,nmax,
     $                   p1,p2,nphot,sphot,sphum,ygr,zet,qq,wtisr)
*     ************************************************************
*======================================================================
* The algorithm in this subprogram was described in:
* ``Yennie-Frautschi-Suura soft photons in Monte Carlo event generators'',
* unpublished report by S. Jadach, MPI-Munchen, MPI-PAE/PTh 6/87, Jan. 1987.
*======================================================================
*================== Y F S G E N =======================================
*======================================================================
**********INPUT
*     cmsene   = total cms energy
*     amel  = beam mass
*     vv    = v=1-s'/s variable
*     vmin  = minimum v variable (infrared cutoff)
*     nmax  = maximum photon multiplicity
**********OUTPUT
* p1,2    = initial fermion momenta (along z-axix)
* nphot   = photon multiplicity
* sphot   = photon four-momenta
* sphum   = total photon four-momentum
* ygr,zet = Sudakov variables
* qq      = 4-mmentum left after photon emission
* wt1     = weight due to neglected mass terms
* wt2     = weight due to dilatation of photon momenta
* wt3     = another dilatation weight
******************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( pi=3.1415926535897932d0,alfinv= 137.03604d0)
      PARAMETER (alf1 = 1d0/pi/alfinv)
      DIMENSION sphum(4),sphot(100,4),ygr(100),zet(100)
* For tests only
      DIMENSION p1(4),p2(4),qq(4),xph(100),rr(100)
      SAVE
*
      ene  = cmsene/2d0
* Define 4-momenta of the initial charged particles (emitters)
      CALL givpair(cmsene,amel,amel,p1,p2,beta,eta1,eta2)
* Here gami2 must be used instead of gami (mass term neglected)
      am2  = (amel/ene)**2
      beta = sqrt(1d0-am2)
      gami2 = 2d0*alf1* dlog((1+beta)**2/am2)
      DO i=1,nmax
         xph(i)=0d0
         ygr(i)=0d0
         zet(i)=0d0
         DO j=1,4
            sphot(i,j)=0d0
         ENDDO
      ENDDO
      IF(vv .LE. vmin) THEN
* no photon above detectability threshold
         wt1=1d0
         wt2=1d0
         wt3=1d0
         nphot=0
      ELSE
* one or more photons, generate photon multiplicity
* nphot = poisson(with average = averg) + 1
         averg=gami2*dlog(vv/vmin)
 100     CONTINUE
         CALL poissg(averg,nmax,multp,rr)
         nphot = multp+1
* this is for tests of program at fixed multiplicity (for adv. users)
         IF((MltISR .NE. 0) .AND. (nphot .NE. MltISR)) GOTO 100
         IF(nphot .EQ. 1) THEN
            xph(1)=vv
         ELSE
            xph(1)=vv
            DO i=2,nphot
               xph(i)=vv*(vmin/vv)**rr(i-1)
            ENDDO
         ENDIF ! nphot
         wt1=1d0
         DO i=1,nphot
            xk=xph(i)
            CALL angbre(am2,del1,del2,cg,sg,dist0,dist1)
            wtm=dist1/dist0
            wt1    =wt1*wtm
            CALL varran(rnumb,1)
            phi=2d0*pi*rnumb
            sphot(i,1)=xk*sg*cos(phi)
            sphot(i,2)=xk*sg*sin(phi)
            sphot(i,3)=xk*cg
            sphot(i,4)=xk
            ygr(i)    =xk*del1/2d0
            zet(i)    =xk*del2/2d0
         ENDDO
         CALL resolh(sphot,nphot,vv,expy,djac)
         djac0=(1d0+1d0/sqrt(1d0-vv))/2d0
         wt2  = djac/djac0
         wt3  = 1d0
* scale down photon energies and momenta
         DO i=1,nphot
            ygr(i) =ygr(i)/expy
            zet(i) =zet(i)/expy
            DO k=1,4
               sphot(i,k)=sphot(i,k)/expy
            ENDDO
         ENDDO
* check on lower energy cut-off
         IF(sphot(nphot,4) .LT. vmin) wt3 =0d0
      ENDIF ! vv
* photon momenta rescaled into GEV units
      DO j=1,4
         sphum(j)=0d0
      ENDDO
      DO  i=1,nphot
         DO  j=1,4
            sphot(i,j)=sphot(i,j)*ene
            sphum(j)=sphum(j)+sphot(i,j)
         ENDDO
      ENDDO
* 4-momentum left after photon emission
      DO k=1,4
         qq(k)=-sphum(k)
      ENDDO
      qq(4)=qq(4)+cmsene
* Total ISR weight
      wtisr = wt1*wt2*wt3
      END

      SUBROUTINE resolh(sphot,nphot,vv,expy,djac)
*     *******************************************
* This routine solves constraint equation on photon momenta,
* also calculates corresponding jacobian factor
* INPUT:  sphot = crude photon momenta
*         nphot = photon multiplicity
*         vv    = costraint parameter v
* OUTPUT  expy  = rescaling factor - a solution of the equation
*         djac  = jacobian factor
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION sphot(100,4)
      DIMENSION pp(4),pk(4)
*
      IF(nphot .EQ. 1) THEN
         expy = 1
         djac = 1
         RETURN
      ENDIF
*
      DO k=1,4
         pk(k)=0d0
         pp(k)=0d0
      ENDDO
      pp(4)=2d0    ! total energy in units of ene
      DO i=1,nphot
         DO k=1,4
            pk(k)=pk(k)+sphot(i,k)
         ENDDO
      ENDDO
      ppdpp=pp(4)**2-pp(3)**2-pp(2)**2-pp(1)**2
      pkdpk=pk(4)**2-pk(3)**2-pk(2)**2-pk(1)**2
      ppdpk=pp(4)*pk(4)-pp(3)*pk(3)-pp(2)*pk(2)-pp(1)*pk(1)
      aa=ppdpp*pkdpk/(ppdpk)**2
      expy=2d0*ppdpk/ppdpp/vv
* solution for constraint on photon four momenta
      expy=expy*.5d0*(1d0+sqrt(1d0-vv*aa))
* jacobian factor
      djac=(1d0+1d0/sqrt(1d0-vv*aa))/2d0
      END
*======================================================================
*==================END of  Y F S G E N ================================
*======================================================================


      SUBROUTINE karfin(mode,xpar,ypar,
     $     ppz,                                       ! input
     $     qf1,qf2,nphot,sphot,sphum,yfin,zfin,wt)    ! output
*=======================================================================
*  Top level Monte Carlo for final state multibremsstrahlung
*=======================================================================
* INPUT:
*     ppz     = 4-momentum of the entire FSR system (fermions+photons)
* OUTPUT:
*     qf1,2   = final state charged particle momenta
*     nphot   = FSR photon multiplicity
*     sphot   = list of FSR photons
*     sphum   = total FSR photon 4-momentum
*     yfin    = Sydakov variable
*     zfin    = Sydakov variable
*     wt      = Crude mc weight
***** input from xpar(*)
*     amfi1,2 = mass of final state charged particles
*     delta   = dimensionless lower cut on IRS real photons
*     emin    = minimum energy in CMS=LAB system (GeV)
************************************************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION xpar(*),ypar(*)
      DIMENSION ppz(4)
* BoX-FORMATs for nice and flexible outputs
      CHARACTER*80      bxope,bxclo,bxtxt,bxl1i,bxl1f,bxl2f,bxl1g,bxl2g
      PARAMETER (
     $  bxope ='(//1x,15(5h*****)    )',
     $  bxtxt ='(1x,1h*,                  a48,25x,    1h*)',
     $  bxl1i ='(1x,1h*,i17,                 16x, a20,a12,a7, 1x,1h*)',
     $  bxl1f ='(1x,1h*,f17.8,               16x, a20,a12,a7, 1x,1h*)',
     $  bxl2f ='(1x,1h*,f17.8, 4h  +-, f11.8, 1x, a20,a12,a7, 1x,1h*)',
     $  bxl1g ='(1x,1h*,g17.8,               16x, a20,a12,a7, 1x,1h*)',
     $  bxl2g ='(1x,1h*,g17.8, 4h  +-, f11.8, 1x, a20,a12,a7, 1x,1h*)',
     $  bxclo ='(1x,15(5h*****)/   )'
     $ )
* Communicates with gmonit
      COMMON / cmonit/ averwt,errela,nevtot,nevacc,nevneg,nevove,nevzer
      COMMON / inout  / ninp,nout
      DIMENSION qf1(4),qf2(4),sphum(4),sphot(100,4)
      DIMENSION yfin(100),zfin(100)
      SAVE
*
      IF(mode .EQ. -1) THEN
*     =====================
      nevgen=0
      martot=0


      KeyFSR = xpar(21)
      KeyPia = xpar(22)
      IF(KeyFSR .EQ. 0) RETURN

      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'initialize karfin  start'
      idyfs = 0
      CALL gbook1(idyfs+20,'karfin: log10(k/eps) marked $',50, 0d0, 5d0)
* additional check on wtctrl, plot of its u-dependence
      CALL gbook1(idyfs+31,'karfin:     u  wtctrl       $',27,.1d0, 1d0)
      CALL gbook1(idyfs+32,'karfin:     u  wt=1         $',27,.1d0, 1d0)
      CALL gmonit(-1,idyfs+60,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+61,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+62,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+63,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+64,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+65,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+66,0d0,1d0,1d0)
      CALL gmonit(-1,idyfs+69,0d0,1d0,1d0)
      WRITE(nout,bxtxt) 'initialize karfin  END  '
      WRITE(nout,bxclo)
*
      ELSEIF(mode .EQ. 0) THEN
*     ======================
      nevgen=nevgen+1
* Final state charge, and mass
      KFfin  = ypar(400)
      kf     = 500+10*KFfin
      charge = xpar(kf+3)/3d0
      charg2 = charge**2
      amfi1  = xpar(kf+6)
      amfi2  = xpar(kf+6)
      IF(KeyFSR .EQ. 1) THEN
*        Infrared cut
         cmsene = xpar( 1)
         vvmin  = xpar(16)
         emin   = cmsene/2d0*vvmin
         delfac = xpar(18)
         delta  = vvmin*delfac
*     Generate photons and fermions in the rest frame of ferms Q=qf1+qf2
*     and transform to LAB system, 
*     ppz=q1+q2+phsu is total momentum of the entire FSR system,
*     as seen from the LAB system.
         MltFSR = xpar(24)
         CALL yfs_fin(
     $        MltFSR,KeyPia,ppz,amfi1,amfi2,delta,emin,charg2,
     $        qf1,qf2,nphot,sphot,sphum,yfin,zfin,wtfin,martot)
         CALL gmonit(0,idyfs+69,wt ,1d0,0d0)
      ELSEIF(KeyFSR .EQ. 0) THEN
*     No final state bremss, fermion momenta defined in Z frame
         CALL phspc2( ppz,amfi1,amfi2,qf1,qf2,wtt)
         wtfin = 1d0
         nphot  = 0
      ELSE
         WRITE(*,*) ' ++++ KarFin: wrong KeyFSR=',KeyFSR
         STOP
      ENDIF
*     main weight
      wt=wtfin
* =============================================
*
      ELSE
*     ====
      IF(KeyFSR .EQ. 0) RETURN
* no printout for mode=1
      IF(mode .EQ. 1) RETURN
*-----------------------------------------------------------------------
*.........................output window a...............................
      CALL gmonit(1,idyfs+60,avmult,dumm2,dumm3)
      CALL gmonit(1,idyfs+61,awt61,dwt61,dumm3)
      CALL gmonit(1,idyfs+62,awt62,dwt62,dumm3)
      CALL gmonit(1,idyfs+63,awt63,dwt63,dumm3)
      CALL gmonit(1,idyfs+69,awt69,dwt69,dumm3)
* general information on weights
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'karfin output - window a'
      WRITE(nout,bxtxt) '    weight statistics   '
      WRITE(nout,bxl2f) awt69,dwt69,' general weight    ','wt    ','a1'
      WRITE(nout,bxl1i) nevgen,     ' generated events  ','nevgen','a2'
      WRITE(nout,bxl1f) avmult,     ' aver. ph. multi.  ','avmult','a3'
      WRITE(nout,bxl1i) martot,     ' marked photons    ','martot','a4'
      WRITE(nout,bxl2f) awt61,dwt61,' kinematics, smin  ','wt1   ','a5'
      WRITE(nout,bxl2f) awt62,dwt62,' jacobian          ','wt2   ','a6'
      WRITE(nout,bxl2f) awt63,dwt63,' photon ang. dist. ','wt3   ','a7'
      WRITE(nout,bxclo)
* specific details on mass weight rearrangenment, and rejection
      CALL gmonit(1,idyfs+64,avmlt,dwt65,dumm3)
      CALL gmonit(1,idyfs+65,awt65,dwt65,dumm3)
      CALL gmonit(1,idyfs+66,awt66,dwt66,dumm3)
      nzer66 = nevzer
      ntot66 = nevtot
      WRITE(nout,bxope)
      WRITE(nout,bxtxt) 'karfin output - window b'
      WRITE(nout,bxtxt) '    on mass weights     '
      WRITE(nout,bxl2f) awt66,dwt66,' removal wgt wtrem ','wt6 ','b1'
      WRITE(nout,bxl1i) ntot66,     ' no. of raw events ','    ','b2'
      WRITE(nout,bxl1i) nzer66,     ' wt6=0      events ','    ','b3'
      WRITE(nout,bxl1f) avmlt,      ' raw ph. multipl.  ','    ','b4'
      WRITE(nout,bxl2f) awt65,dwt65,' control wgt wctrl ','wt5 ','b5'
      WRITE(nout,bxl1g) emin,       ' emin              ','    ','b6'
      WRITE(nout,bxl1g) delta,      ' delta             ','    ','b7'
      WRITE(nout,bxclo)
* histograms
*      CALL gprint(idyfs+20)
*      CALL gopera(idyfs+31,'/',idyfs+32,idyfs+33,1d0,1d0)
*      CALL gprint(idyfs+33)
      ENDIF
*     =====
      END


      SUBROUTINE yfs_fin(
     $     MltFSR,KeyPia,ppz,amch1,amch2,delta,emin,charg2,
     $     q1,q2,nphot,phot,phsu,ygr,zet,wtfin,martot)
*     *****************************************************************
* Simulates final state bremsstrahlung out of pair of charged patricles.
* (algorithm of 11-th march 1989, SJ)
* INPUT  : 
*     ppz     = 4-momentum of FSR system as seen from LAB system
*     amch1,2 = masses of the final charged pair
*     delta   = lower energy bound (dimensionless)
*     emin    = lower energy bound (GeV) in LAB system
* OUTPUT : 
*     q1,2    = final fermion four momentum (GeV)
*     nphot   = photon multiplicity
*     phot    = photon four momenta (GeV) in cms
*     phsu    = sum of photon momenta
*     ygr,zet = Sudakov variables
*     martot  = control variable, no of marked photons
* OTHER:
*     mk     = marks on photons CLOSE to lower energy bound
*     q1c,2c = fictisious final fermion four momenta for crude S-factor
*     wt1    = the weight - phase space limits for very hard phot.
*     wt2    = the weight - translation jacobian.
*     wtm    = the list/matrix of mass weights.
*     **************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER(pi=3.1415926535897932d0,alfinv=137.03604d0)
      PARAMETER (alf1 = 1d0/pi/alfinv)
      DIMENSION phot(100,4),phsu(4),mk(100),wtm(100)
      DIMENSION ppz(4),q1(4),q2(4),q1c(4),q2c(4)
      DIMENSION ygr(100),zet(100)
*
      DIMENSION rr(100),xk(100),cgx(100),sgx(100)
      DIMENSION dis0(100)
      DIMENSION drvec(100)
      SAVE

*-----------------------------------------------------------------------
      wt1   =1d0
      wt2   =1d0
      wt3   =1d0
      wctrl =1d0
      wtrem =1d0
*-----------------------------------------------------------------------
      svar = ppz(4)**2-ppz(3)**2-ppz(2)**2-ppz(1)**2
      amfin = MIN(amch1,amch2)
      amc2  = 4.d0*amfin**2/svar  ! overvalued svar for crude
      betc  = sqrt(1d0-amc2)      ! overvalued svar for crude
      DO i=1,100
         rr(i)=0.d0
         mk(i)=0
      ENDDO
      DO k=1,4
         phsu(k)=0.d0
      ENDDO
      DO i=1,100
         ygr(i)=0
         zet(i)=0
         DO k=1,4
            phot(i,k)=0.d0
         ENDDO
      ENDDO
*-----------------------------------------------------------------------
*     generate photon multiplicity, averg = average multiplicity (crude)
*-----------------------------------------------------------------------
      gamf2 = charg2*alf1 *(1+betc**2)/betc *dlog((1d0+betc)**2/amc2)
      averg = gamf2*dlog(1/delta)
      nmax=50
    5 CONTINUE
      CALL poissg(averg,nmax,nphot,rr)
** This is for tests of program at fixed multiplicity (advanc. users)
      IF((MltFSR .NE. 0) .AND. (nphot .NE. MltFSR)) GOTO 5
**
      IF(nphot .EQ. 0) THEN
         sprim=svar
      ELSE
*-----------------------------------------------------------------------
*     begin with photon energy
         xsum=0.d0
         DO  i=1,nphot
            xk(i)=delta**rr(i)
            IF(xk(i) .LT. sqrt(10.d0)*delta) mk(i)=1
            xsum=xsum+xk(i)
         ENDDO
         IF(xsum .GE. 1.d0) GOTO 900
         xfact=1d0/(1.d0-xsum)
         DO i=1,nphot
            xk(i)=xk(i)*xfact
         ENDDO
         CALL varran(drvec,nphot)
         DO i=1,nphot
*-----------------------------------------------------------------------
*     simplified photon angular distribution,
*     s'->s and m**2/(kp)**2 dropped
*     cg=cos(theta) and sg=sin(theta) memorized to avoid rounding err.
            CALL angbre(amc2,dl1,dl2,cg,sg,dis0(i),dis1)
*-----------------------------------------------------------------------
*     define photon momenta (in units of sqrt(s')/2 )
            phi=2.d0*pi*drvec(i)
            phot(i,1)=xk(i)*sg*cos(phi)
            phot(i,2)=xk(i)*sg*sin(phi)
            phot(i,3)=xk(i)*cg
            phot(i,4)=xk(i)
            DO k=1,4
               phsu(k)=phsu(k)+phot(i,k)
            ENDDO
            cgx(i)=cg
            sgx(i)=sg
         ENDDO
*-----------------------------------------------------------------------
*     determine rescaling factor and s', wt2 is dilatation jacobian
         xmk2 = phsu(4)**2-phsu(3)**2-phsu(2)**2-phsu(1)**2
         yy   = 1.d0/(1.d0 +phsu(4) +xmk2/4.d0 )
         wt2  = yy*(1.d0+phsu(4))
         sprim= svar*yy
*-----------------------------------------------------------------------
*     reject events with too hard photons
         smini= (amch1+amch2)**2
         IF(sprim .LT. smini) GOTO 900
*-----------------------------------------------------------------------
*     Recsale properly all photon momenta
*-----------------------------------------------------------------------
         ener = sqrt(sprim)/2.d0
         DO  k=1,4
            phsu(k)= phsu(k)*ener
            DO  i=1,nphot
               phot(i,k)=phot(i,k)*ener
            ENDDO
         ENDDO
      ENDIF ! nphot
*-----------------------------------------------------------------------
*     final fermion momenta
*-----------------------------------------------------------------------
      amcru  = amfin*sqrt(sprim/svar)
      qmsene = sqrt(sprim)
      ener   = qmsene/2d0
      CALL givpair(qmsene,amch1,amch2,q1, q2 ,betn,eta1,eta2)! real
      CALL givpair(qmsene,amcru,amcru,q1c,q2c,betc,etc1,etc2)! ghost
*-----------------------------------------------------------------------
*     Mass weight for theta distribution
*-----------------------------------------------------------------------
*     Mass weight compensates for s'->s and droping terms -m**2/(k.q)**2
*     Care is taken of machine rounding errors.
*     del1 and del2 RECALCULATED out of angles sgx(i),cgx(i)
*     with TRUE sprim, using EXACT formulas
      amd1 = (amch1/ener)**2
      amd2 = (amch2/ener)**2
      DO i=1,nphot
         IF( cgx(i) .GT. 0.d0 ) THEN
            del1 = amd1/(eta1+betn) +betn*sgx(i)**2/(1+cgx(i))
            del2 = eta2 +betn*cgx(i)
         ELSE
            del1 = eta1 -betn*cgx(i)
            del2 = amd2/(eta2+betn) +betn*sgx(i)**2/(1-cgx(i))
         ENDIF
         dist1=1d0/(del1*del2) 
     $        *(1d0 -(amd1+amd2)/4d0
     $                   -amd2/4d0*del1/del2 -amd1/4d0*del2/del1)
         wtm(i)= dist1/dis0(i)
         IF(wtm(i) .LT.  1.d-90) wtm(i)= 0.d0
***********
** dist1x below is exactly the same as dist1 but for small masses is 
** prone to severe rounding errors (in contrast to dist1 used above)
*         IF((1-sprim/svar) .gt. 0.01d0) THEN
*            q1q2= q1(4)*q2(4) -q1(3)*q2(3) -q1(2)*q2(2) -q1(1)*q2(1)
*            q1k = q1(4)*phot(i,4)-q1(3)*phot(i,3)
*     $           -q1(2)*phot(i,2)-q1(1)*phot(i,1)
*            q2k = q2(4)*phot(i,4)-q2(3)*phot(i,3)
*     $           -q2(2)*phot(i,2)-q2(1)*phot(i,1)
*            dist1x = 2*q1q2/q1k/q2k -amch1**2/q1k**2 -amch2**2/q2k**2
*            dist1x = dist1x/4d0*phot(i,4)**2
*            WRITE(*,'(a,5f20.10)') '===>: ',dist1x/dist1
*         ENDIF
***********
*     finaly define Sudakov variables
         ygr(i)=del1*xk(i)/2d0
         zet(i)=del2*xk(i)/2d0
      ENDDO
*-----------------------------------------------------------------------
* transform from rest frame of Q=qf1+qf2 down to CMS=Lab,
* through ppz=q1+q2+phsu where Euler rotation is done.
*-----------------------------------------------------------------------
      CALL varran(drvec,2)
      cth= 1.d0 -2.d0*drvec(1)
      the= acos(cth)
      phi= 2.d0*pi*drvec(2)
      CALL kinf1(ppz,the,phi,q1,q2,q1c,q2c,nphot,phot,phsu)
*-----------------------------------------------------------------------
* Calculate YFS formfactor (cut-off dependent part) and mass weights
* Optionally removing photons below emin from the list
      CALL piatek(KeyPia,amch1,amch2,emin,delta,charg2,
     $     q1,q2,q1c,q2c,phsu,phot,nphot,wtm,wtrem,wt3,wctrl)
      GOTO 1000
*-----------------------------------------------------------------------
* Event outside phase space (too hard photon)
 900  CONTINUE
      wt1 =0.d0
      wt2=1.d0
      nphot=-1
*-----------------------------------------------------------------------
 1000 CONTINUE
      wtfin = wt1*wt2*wt3
*-----------------------------------------------------------------------
* Monitoring weights and other control variables,
* Non-essential for the MC generation itself.
      uu = 1d0-sprim/svar
      uu=1d0
      CALL gmonit(0,idyfs+64 ,1d0*nphot,20d0,0d0)
      CALL gmonit(0,idyfs+65 ,wctrl,1d0,0d0)
      CALL gf1(idyfs+31, uu  ,wctrl)
      CALL gf1(idyfs+32, uu  ,  1d0)
      CALL gmonit(0,idyfs+66 ,wtrem,1d0,0d0)
* Monitoring weights
      CALL gmonit(0,idyfs+60,1d0*nphot,20d0,0d0)
      CALL gmonit(0,idyfs+61,wt1,1d0,0d0)
      CALL gmonit(0,idyfs+62,wt2,1d0,0d0)
      CALL gmonit(0,idyfs+63,wt3,1d0,0d0)
* marked photons
      IF(nphot .GE. 1) THEN
         DO i=1,nphot
            ul= log10(phot(i,4)/emin)
            IF(mk(i) .EQ. 1)   CALL gf1(idyfs+20,   ul,1.d0)
            IF(mk(i) .EQ. 1)   martot=martot+1
         ENDDO
      ENDIF
      END

      SUBROUTINE kinf1(ppz,the,phi,q1,q2,q1c,q2c,nphot,phot,phsu)
*     ***********************************************************
* Transforms to CMS: phot, phsu, q1,q2
* with random Euler rotation in the intermediate ppz frame (Z frame)
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( pi = 3.1415926535897932d0)
      DIMENSION ppz(4),phot(100,4),phsu(4),q1(4),q2(4),q1c(4),q2c(4)
      DIMENSION ph(4),qqk(4)

      DO k=1,4
         qqk(k)=q1(k)+q2(k)+phsu(k)
      ENDDO
      DO i=1,nphot
         DO k=1,4
            ph(k)=phot(i,k)
         ENDDO
         CALL boteul(qqk,ppz,the,phi,ph,ph)
         DO k=1,4
            phot(i,k)= ph(k)
         ENDDO
      ENDDO
      CALL boteul(qqk,ppz,the,phi,q1,q1)
      CALL boteul(qqk,ppz,the,phi,q2,q2)
      CALL boteul(qqk,ppz,the,phi,q1c,q1c)
      CALL boteul(qqk,ppz,the,phi,q2c,q2c)
      CALL boteul(qqk,ppz,the,phi,phsu,phsu)
      END

      SUBROUTINE boteul(qqk,ppz,the,phi,pvec,qvec)
*     *******************************************
* Euler rotation and boosts
      IMPLICIT REAL*8(a-h,o-z)
      REAL*8 pvec(4),qvec(4),qqk(4),ppz(4)

      CALL bostdq( 1,qqk,pvec,qvec)
      CALL rotod1(   the,qvec,qvec)
      CALL rotod3(   phi,qvec,qvec)
      CALL bostdq(-1,ppz,qvec,qvec)
      END

      SUBROUTINE piatek(KeyPia,amch1,amch2,emin,delta,charg2,
     $     qf1,qf2,qf1c,qf2c,phsu,phot,nphot,wtmas,wtrem,wtm3a,wctrl)
*     *****************************************************************
* Written CERN, piatek, 22 sept. 1989  (S.J.)
* Note the action of this routine is not Loretnz invariant !!!!
* Input:  KeyPia   = 0, NO removal of photons below emin
*                  = 1, with removal of photons below emin
*         amch1,2  = fermion masses
*         emin     = emin minimum-energy of photons to be kept (GeV)
*         delta    = infrared cut-off in generation (dimensionless)
*         qf1,2    = fermion momenta
*         qf1c,2c  = ghost fermion momenta in crude S-factor
*         phsu     = sum of photon momenta
*         phot     = list of photon momenta
*         amch1,2  = fermion masses (GeV)
*         wtmas    = list of mass-weights for all photons
* Output: wtrem    = 1,  for KeyPia=0
*                  = mass-weight of removed photons, for KeyPia=1
*         wtm3a    = mass-weight for all photons, see comments below
*         wctrl    = control-weight for remowed photons
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER(pi=3.1415926535897932d0,alfinv=137.03604d0)
      PARAMETER (alf1 = 1d0/pi/alfinv)
      DIMENSION  qf1(4),qf2(4),qf1c(4),qf2c(4),phsu(4),phot(100,4)
      DIMENSION  wtmas(100)
      SAVE
      DIMENSION qq(4),pp(4)

      alfc = alf1*charg2
      amfin = MIN(amch1,amch2)
      DO k=1,4
         pp(k) = qf1(k)+qf2(k) +phsu(k)
         qq(k) = qf1(k)+qf2(k)
      ENDDO
      svar = pp(4)**2-pp(3)**2 -pp(2)**2 -pp(1)**2
      sprim= qq(4)**2-qq(3)**2 -qq(2)**2 -qq(1)**2
      wtm1=1d0
      wtm2=1d0
* mass weight below and above emin calculated separately
      DO i=1,nphot
         IF(phot(i,4) .LT. emin) THEN
            wtm1=wtm1*wtmas(i)
            IF(wtm1 .LE. 1d-90) wtm1=0d0
         ELSE
            wtm2=wtm2*wtmas(i)
            IF(wtm2 .LE. 1d-90) wtm2=0d0
         ENDIF
      ENDDO
* Delt1 and eps1 are cutoffs located in YFS formfactor
* Note that xfact=(1+2*qqk/sprim) is EXACTLY the same as in yfs_fin
      qqk  = qq(4)*phsu(4)-qq(3)*phsu(3)-qq(2)*phsu(2)-qq(1)*phsu(1)
      delt1 =  delta*(1+ 2*qqk/sprim)
      eps1  =  sqrt(emin**2/qf1(4)/qf2(4))
* The total phase space integral for crude x-section,
* Note that delta is a lower limit on y-variables in crude generation
      amc2  =  4d0*amfin**2/svar
      betc  =  dsqrt(1d0-amc2)
      fphs  =  2*alfc
     $     *(1d0+betc**2)/(2d0*betc)* dlog((1d0+betc)**2/amc2) 
     $     *dlog(1/delta)
* YFS formfactor cut-off dependend part: 
* delt1 = 2*Emin/sqrt(s'), where Emin is infrared cut-off in QMS
      q1q2= qf1(4)*qf2(4) -qf1(3)*qf2(3) -qf1(2)*qf2(2) -qf1(1)*qf2(1)
      fyfs  = -2d0*alfc
     $     *( q1q2*Aanal(q1q2,amch1,amch2) -1d0 )
     $     *dlog(1/delt1)
      delb  =  fyfs + fphs
* The average mass-weight for removed photon = exp(delb2)
* It can be calculated analyticaly as a  ratio of YFS formfactors
* On the other hand, it is checked by MC, see control weight wtctrl
* Ultrarelativistic (small mass) old version
      delb2u = -2*alfc*(dlog(svar/sprim)+1) *dlog(eps1/delt1)
* Delb2 used actualy
      IF( (amch1+amch2)**2/svar .LT. 1d-5) THEN
         delb2 = delb2u
      ELSE
* Complete delb2 for finite amfin
         delb2 = delb2f(emin,delta,amch1,amch2,qf1,qf2,qf1c,qf2c,phsu)
      ENDIF
* Approximate version of delb2 without A4 function for tests
*      delb2w = -2*alfc*(
*     $     (1d0+betc**2)/(2d0*betc)* dlog((1d0+betc)**2/amc2) 
*     $     -( q1q2*Aanal(q1q2,amch1,amch2) -1d0 )
*     $     ) *dlog(eps1/delt1)
*****[[[[[[*********DEBUG****
*      IF((1-sprim/svar) .gt. 0.01d0) THEN
*         delb2m = delb2f(emin,delta,amch1,amch2,qf1,qf2,qf1c,qf2c,phsu)
*         WRITE(*,'(a,5f20.10)')
*     $  'piatek: ',1-sprim/svar,delb2m,delb2u/delb2m,delb2w/delb2m
*      ENDIF
*****]]]]]]*********DEBUG****
* Control weight - its average should be =1 within statist. error
      wctrl =wtm1*exp(-delb2)
      IF(KeyPia .EQ. 0) THEN
         IF(abs(delb) .GT. 100d0 ) WRITE(*,*) ' delb= ',delb
         wtrem = 1d0
         wtm3a = wtm1*wtm2*exp(delb)
      ELSE
* Optional removal of photons below emin from the record
* in such a case wtm3a includes exp(belb2)= <wt3> for removed ph.
         nph=nphot
         DO j=nphot,1,-1
            IF(phot(j,4) .LT. emin) THEN
               DO i=j+1,nph
                  DO k=1,4
                     phot(i-1,k)=phot(i,k)
                  ENDDO
               ENDDO
               nph=nph-1
            ENDIF
         ENDDO
* Correction of Alex Read
         DO j=nph+1,nphot
            DO k=1,4
               phot(j,k) = 0.d0
            ENDDO
         ENDDO
         nphot=nph
* wtmas includes here average weight of removed photons exp(delb2)
         wtrem = wtm1
         wtm3a = wtm2*exp(delb+delb2)
      ENDIF
      END ! piatek


      SUBROUTINE phspc2(qq,am1,am2,q1,q2,wt)
*     **************************************
* Generates q1, q2 with masses am1,am2, such that qq = q1,q2
* In the qq rest frame spherical density is flat
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      PARAMETER( pi = 3.1415926535897932d0)
      DIMENSION qq(*),q1(*),q2(*),drvec(10)

      cmsene= sqrt(qq(4)**2-qq(3)**2-qq(2)**2-qq(1)**2)
      CALL varran(drvec,2)
      cth= 1.d0 -2.d0*drvec(1)
      the= acos(cth)
      phi= 2.d0*pi*drvec(2)
      CALL givpair(cmsene,am1,am2,q1,q2,beta,eta1,eta2)
      CALL roteul(the,phi,q1,q1)
      CALL bostdq(  -1,qq,q1,q1)
      CALL roteul(the,phi,q2,q2)
      CALL bostdq(  -1,qq,q2,q2)
      wt = beta/2d0
      END

      SUBROUTINE givpair(cmsene,am1,am2,p1,p2,beta,eta1,eta2)
*     *******************************************************
* For CMS energy = cmsene it defines two "decay" momenta p1,p2
* in their rest frame, along z-axix
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION p1(*),p2(*)
*
      ener  =  cmsene/2d0
      svar  =  cmsene**2
      beta  =  sqrt((svar-(am1-am2)**2)
     $             *(svar-(am1+am2)**2))/svar
      eta1=    (svar+am1**2-am2**2)/svar
      eta2  =  (svar-am1**2+am2**2)/svar

      p1(1)  =  0d0
      p1(2)  =  0d0
      p1(3)  =  ener*beta
      p1(4)  =  ener*eta1

      p2(1)  =  0d0
      p2(2)  =  0d0
      p2(3)  = -ener*beta
      p2(4)  =  ener*eta2
      END

      SUBROUTINE roteul(the,phi,pvec,qvec)
*     ************************************
* Euler rotation
      IMPLICIT REAL*8(a-h,o-z)
      REAL*8 pvec(4),qvec(4)
      CALL rotod1(the,pvec,qvec)
      CALL rotod3(phi,qvec,qvec)
      END
*======================================================================
*=====================end of karfin part===============================
*======================================================================


      SUBROUTINE poissg(averg,nmax,mult,rr)
*     **************************************
* Last corr. nov. 91
* This generates photon multipl. nphot according to poisson distr.
* Input:  averg = average multiplicity
*         nmax  = maximum multiplicity
* Output: mult = generated multiplicity
*         rr(1:100) list of ordered uniform random numbers,
*         a byproduct result, to be eventually used for some further
*         purpose (i.e.  generation of photon energies).
*     ************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION rr(*)
      SAVE
      DATA nfail/0/
*
 50   nn=0
      sum=0d0
      DO it=1,nmax
         CALL varran(rn,1)
         y= log(rn)
         sum=sum+y
         nn=nn+1
         rr(nn)=sum/(-averg)
         IF(sum .LT. -averg) GOTO 130
      ENDDO
      nfail=nfail+1
      IF(nfail .GT. 100) GOTO 900
      GOTO 50
 130  mult=nn-1
      RETURN
 900  WRITE(*,*) ' poissg: to small nmax'
      STOP
      END

      SUBROUTINE angbre(am2,del1,del2,costhg,sinthg,dist0,dist1)
*     **********************************************************
* This routine generates photon angular distribution
* in the rest frame of the fermion pair.
* The distribution is the S-factor without mass term,
* i.e. without terms 2p_1p_2/(kp_1)(kp_2)
* Fermion mass is treated exactly!
* INPUT:  am2 = 4*massf**2/s where massf is fermion mass
*         and s is effective mass squared of the parent fermion-pair.
* OUTPUT: costhg, sinthg, cos and sin of the photon
*         angle with respect to fermions direction
*         dist0 = distribution generated, without m**2/(kp)**2 terms
*         dist1 = distribution with m**2/(kp)**2 terms
*     ***************************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION rn(10)

      CALL varran(rn,2)
      beta =sqrt(1.d0-am2)
      eps  =am2/(1.d0+beta)                     != 1-beta
      del1 =(2.d0-eps)*(eps/(2.d0-eps))**rn(1)  != 1-beta*costhg
      del2 =2.d0-del1                           != 1+beta*costhg
* calculation of sin and cos theta from internal variables
      costhg=(del2-del1)/(2*beta)               ! exact
      sinthg=sqrt(del1*del2-am2*costhg**2)      ! exact
* symmetrization
      IF(rn(2) .LE. 0.5d0) THEN
        a=del1
        del1=del2
        del2=a
        costhg= -costhg
      ENDIF
      dist0=1d0/(del1*del2)*(1d0 -am2/2d0)
      dist1=1d0/(del1*del2) 
     $     *(1d0 -am2/2d0 -am2/4d0*(del1/del2+del2/del1))
* totaly equivalent formula is the following
*     dist1=1d0/(del1*del2)   *beta*sinthg**2/(del1*del2)
      END

*=======================================================================
* borny and bornv define Born x-section for crude MC distributions
*=======================================================================
      FUNCTION borny(vv,xpar,ypar)
*     *******************************
* this routine calculates total born cross section.
* it exploits the fact that born x. section = a + b*c + d*c**2
*     ********************
      IMPLICIT DOUBLE PRECISION  (a-h,o-z)
      DIMENSION xpar(*),ypar(*)
      cmsene = xpar(1)
      svar1  = (1-vv)*cmsene**2
      f0=bornv(svar1, 0.d0,xpar,ypar)
      borny= f0
      END

      FUNCTION bornv(svar,costhe,xpar,ypar)
*     *************************************
* This routine provides unsophisticated Born differential cross section
* at the crude x-section level, with Z and gamma s-chanel exchange
*     ***********************************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION xpar(*),ypar(*)
      SAVE
*
      s = svar

      amaz   = xpar(502)
      sinw2  = xpar(503)
      gammz  = xpar(504)
      KeyZet = xpar(501)
      HadMin = xpar(51)

* Z and gamma couplings to beams (electrons)

      KFbeam = 11           ! KF=11 is electron
      ke = 500+10*KFbeam
      T3e = xpar(ke+4)/2d0  ! isospin, L-hand component
      Qe  = xpar(ke+3)/3d0  ! electric charge
      deno= 4d0*sqrt(sinw2*(1d0-sinw2))
      Ve= (2*T3e -4*Qe*sinw2)/deno
      Ae=  2*T3e             /deno

* Z and gamma couplings to final fermions
* Loop over all flavours defined in xpar(400+i)
      sum = 0d0
      DO i=1,20
         KFfin = xpar(400+i)
         Born =0d0
         IF(  ((KFfin .GE.  1) .AND. (KFfin .LE.  6)) .OR.
     $        ((KFfin .GE. 11) .AND. (KFfin .LE. 16))   ) THEN
*
            kf = 500+10*KFfin
            amfin = xpar(kf+6)
            NCf   = xpar(kf+2)
            T3f   = xpar(kf+4)/2d0 ! isospin, L-hand component
            Qf    = xpar(kf+3)/3d0 ! electric charge
            deno  = 4d0*sqrt(sinw2*(1d0-sinw2))
            Vf = (2*T3f -4*Qf*sinw2)/deno
            Af =  2*T3f             /deno
            
            IF(KeyZet .LE. 0) THEN
               Ve=0d0
               Ae=0d0
            ENDIF

*************
            IF(abs(costhe) .GT. 1d0) 
     $           WRITE(*,*) ' Bornv: costhe=',costhe
*************

            chi2 =         s**2/((s-amaz**2)**2+(gammz*amaz)**2)
            rechi=(s-amaz**2)*s/((s-amaz**2)**2+(gammz*amaz)**2)
            xe= Ve**2 +Ae**2
            xf= Vf**2 +Af**2
            ye= 2*Ve*Ae
            yf= 2*Vf*Af
            ff0= qe**2*qf**2 +2*rechi*qe*qf*Ve*Vf +chi2*xe*xf
            ff1=             +2*rechi*qe*qf*Ae*Af +chi2*ye*yf
            Born    = (1d0+ costhe**2)*ff0 +2d0*costhe*ff1
* Colour factor
            Born = NCf*Born
* This is a bit crude method of introducing threshold behaviour
* cos(theta) depencence incorrect!!!
            IF(    svar .LE.  4d0*amfin**2) THEN
               thresh=0d0
            ELSEIF(svar .LE. 16d0*amfin**2) THEN
               amx2=4d0*amfin**2/svar
               thresh=sqrt(1d0-amx2)*(1d0+amx2/2d0)
            ELSE
               thresh=1d0
            ENDIF
            Born= Born*thresh
         ENDIF
* For light quarks u,d,s, special cut on mass (just in case)
         IF( (KFfin .GE. 1) .AND. (KFfin .LE. 3)) THEN
            IF( svar .LE. HadMin**2) Born=0d0
         ENDIF
         sum = sum +Born
         ypar(400+i)=Born
      ENDDO
      Bornv = sum
      END

*=======================================================================
*=======================================================================
*     subprograms for control printouts of events
*=======================================================================
*=======================================================================

      SUBROUTINE  momprt(txt,
     $     nout,iev,ie1,ie2,pf1,pf2,qf1,qf2,nphot,sphot,KFfin)
*     ***********************************************************
* Prints out four momenta of Beams and Final state particles,
* and the serial number of event iev on unit nout
*     **********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION  pf1(4),pf2(4),qf1(4),qf2(4),sphum(4),sphot(100,4)
      CHARACTER*8 txt
      DIMENSION sum(4)

      IF( (iev .GE. ie1) .AND. (iev .LE. ie2) ) THEN
         WRITE(nout,*) 
     $        '=========== ',txt,' ======================>',iev
*
         amf1 = pf1(4)**2-pf1(3)**2-pf1(2)**2-pf1(1)**2
         amf1 = sqrt(abs(amf1))
         amf2 = pf2(4)**2-pf2(3)**2-pf2(2)**2-pf2(1)**2
         amf2 = sqrt(abs(amf2))
         WRITE(nout,3100) 'pf1',(  pf1(  k),k=1,4),amf1
         WRITE(nout,3100) 'pf2',(  pf2(  k),k=1,4),amf2
*
         amf1 = qf1(4)**2-qf1(3)**2-qf1(2)**2-qf1(1)**2
         amf1 = sqrt(abs(amf1))
         amf2 = qf2(4)**2-qf2(3)**2-qf2(2)**2-qf2(1)**2
         amf2 = sqrt(abs(amf2))
         WRITE(nout,3100) 'qf1',(  qf1(  k),k=1,4),amf1,KFfin
         WRITE(nout,3100) 'qf2',(  qf2(  k),k=1,4),amf2,KFfin
*
         DO i=1,nphot
            amph = sphot(i,4)**2-sphot(i,3)**2
     $            -sphot(i,2)**2-sphot(i,1)**2
            amph = sqrt(abs(amph))
            WRITE(nout,3100) 'pho',(sphot(i,k),k=1,4),amph
         ENDDO
         DO k=1,4
            sum(k)=qf1(k)+qf2(k)
         ENDDO
         DO i=1,nphot
            DO k=1,4
               sum(k)=sum(k)+sphot(i,k)
            ENDDO
         ENDDO
         ams = sum(4)**2-sum(3)**2-sum(2)**2-sum(1)**2
         ams = sqrt(abs(ams))
         WRITE(nout,3100) 'sum',(  sum(  k),k=1,4),ams
      ENDIF

 3100 FORMAT(1x,a3,1x,5f20.14,i5)
      END

      SUBROUTINE dumpri(txt,nout,iev,ie1,ie2,qf1,qf2,nphot,sphot)
*     ***********************************************************
* Prints out four momenta of FINAL state
* and the serial number of event iev on unit nout
*     **********************
      IMPLICIT DOUBLE PRECISION (a-h,o-z)
      DIMENSION  qf1(4),qf2(4),sphum(4),sphot(100,4)
      CHARACTER*8 txt
      DIMENSION sum(4)

      IF( (iev .GE. ie1) .AND. (iev .LE. ie2) ) THEN
         WRITE(nout,*) 
     $        '=========== ',txt,' ======================>',iev
         amf1 = qf1(4)**2-qf1(3)**2-qf1(2)**2-qf1(1)**2
         amf1 = sqrt(abs(amf1))
         amf2 = qf2(4)**2-qf2(3)**2-qf2(2)**2-qf2(1)**2
         amf2 = sqrt(abs(amf2))
         WRITE(nout,3100) 'qf1',(  qf1(  k),k=1,4),amf1
         WRITE(nout,3100) 'qf2',(  qf2(  k),k=1,4),amf2
         DO i=1,nphot
            amph = sphot(i,4)**2-sphot(i,3)**2
     $            -sphot(i,2)**2-sphot(i,1)**2
            amph = sqrt(abs(amph))
            WRITE(nout,3100) 'pho',(sphot(i,k),k=1,4),amph
         ENDDO
         DO k=1,4
            sum(k)=qf1(k)+qf2(k)
         ENDDO
         DO i=1,nphot
            DO k=1,4
               sum(k)=sum(k)+sphot(i,k)
            ENDDO
         ENDDO
         ams = sum(4)**2-sum(3)**2-sum(2)**2-sum(1)**2
         ams = sqrt(abs(ams))
         WRITE(nout,3100) 'sum',(  sum(  k),k=1,4),ams
      ENDIF

 3100 FORMAT(1x,a3,1x,5f20.14)
      END

