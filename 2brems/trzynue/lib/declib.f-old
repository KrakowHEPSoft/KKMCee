C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
C>>>>>>
C>>>>>   Z0_dec         -----Library
C>>>>>>
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      FUNCTION FUNSKI(T1,T2)
C     ************************************
C two dimensional distribution to be generated by package VESK2W
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON / PARFUN / SVAR,XMIN,Z1,Z2
      COMMON / WEKINP / AMAZ,GAMMZ,SINW2
      COMMON /BREMSTR/ KEYBRE,KEYPRO
      DIMENSION RN(2)
  
      CALL VARRAN(RN,2)

C=========initial or final state bremsstrahlung will follows

     
      ALFA=AMAZ/DSQRT(SVAR)
      BETA=AMAZ*GAMMZ/SVAR

      U = XMIN * (1D0/XMIN**2)**T1

      XP1=(1D0/XMIN - 1D0)
      XP2=1D0 / BETA * (
     #   ATAN((1D0-ALFA**2)/BETA)
     #  -ATAN((XMIN-ALFA**2)/BETA)   )

      IF(RN(1).LT.XP1/(XP1+XP2)) THEN
          V=1D0/((1D0-T2)/XMIN+T2)
      ELSE
          V=ALFA**2+BETA*TAN(
     #        T2 *ATAN((1D0-ALFA**2)/BETA)
     #  +(1D0-T2)*ATAN((XMIN-ALFA**2)/BETA)  )
      ENDIF

      IF(RN(2).LT.0.5D0) THEN
         Z1=DSQRT(V*U)
         Z2=DSQRT(V/U)
      ELSE
         Z2=DSQRT(V*U)
         Z1=DSQRT(V/U)
      ENDIF
C jacobian
      RJAC= (XP1+XP2)*DLOG(1D0/XMIN)
C anticipated functions
      DD1 = 1D0
      DD2 = 1D0
C anticipated trigger
      WTRIG = 1D0
      IF(Z1*Z2.LT.XMIN.OR.Z1*Z2.GT.1D0) WTRIG=0D0
      IF(Z1.GT.1D0.OR.Z2.GT.1D0) WTRIG=0D0
C 
      FUNSKI = RJAC*WTRIG*DD1*DD2/SVAR



      RETURN
  900 FUNSKI = 0D0

      END
      SUBROUTINE BEAMAS(CMSENE,AMAS,P1,P2)
C     ***********************************************
C  calculating beam momenta P1,P2 in CMS system with energy CMSENE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION P1(4),P2(4)

      P1(4)= CMSENE/2D0
      P1(3)= CMSENE/2D0*DSQRT(1D0-4D0*AMAS**2/CMSENE**2)
      P1(2)= 0D0
      P1(1)= 0D0
      P2(4)= CMSENE/2D0
      P2(3)=-CMSENE/2D0*DSQRT(1D0-4D0*AMAS**2/CMSENE**2)
      P2(2)= 0D0
      P2(1)= 0D0
 
      END

C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
C>>>>>>
C>>>>>   Y F S  3         -----Library
C>>>>>>
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      SUBROUTINE GSOFA1(P1,P2,PH,F1,F2)
C     *********************************
C CALCULATES INGREDIENTS FOR REAL SINGLE PHOTON DIFF. XSECTION
C     *****************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PH(*),P1(*),P2(*)
      AM2= P1(4)**2-P1(1)**2-P1(2)**2-P1(3)**2
      PK1= P1(4)*PH(4)-P1(1)*PH(1)-P1(2)*PH(2)-P1(3)*PH(3)
      PK2= P2(4)*PH(4)-P2(1)*PH(1)-P2(2)*PH(2)-P2(3)*PH(3)
      PP = P1(4)*P2(4)-P1(1)*P2(1)-P1(2)*P2(2)-P1(3)*P2(3)
C     A  =  PK2/PP
C     B  =  PK1/PP
      B  =  PK2/PP
      A  =  PK1/PP
      SFAC1  =  2D0*PP/PK1/PK2
      AM = AM2/(2D0*PP)
      WWM= 1D0-AM*2D0*(1D0-A)*(1D0-B)/((1D0-A)**2+(1D0-B)**2)*(A/B+B/A)
      F1   = 0.5D0*(1D0-A)**2*WWM *SFAC1
      F2   = 0.5D0*(1D0-B)**2*WWM *SFAC1
      END
      SUBROUTINE GSFIN1(P1,P2,PH,F1,F2)
C     *********************************
C Final state now! but P <=> replacement kept
C CALCULATES INGREDIENTS FOR REAL SINGLE PHOTON DIFF. XSECTION
C     *****************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PH(*),P1(*),P2(*)
      AM2= P1(4)**2-P1(1)**2-P1(2)**2-P1(3)**2
      PK1= P1(4)*PH(4)-P1(1)*PH(1)-P1(2)*PH(2)-P1(3)*PH(3)
      PK2= P2(4)*PH(4)-P2(1)*PH(1)-P2(2)*PH(2)-P2(3)*PH(3)
      PP = P1(4)*P2(4)-P1(1)*P2(1)-P1(2)*P2(2)-P1(3)*P2(3)
C
      BB =  ABS(PK2)/PP
      AA =  ABS(PK1)/PP
      A  = AA/(1 +AA+BB)
      B  = BB/(1 +AA+BB)
      SFAC1  =  2D0*PP/PK1/PK2
      AM = AM2/(2D0*PP)
      WWM= 1D0-AM*2D0*(1D0-A)*(1D0-B)/((1D0-A)**2+(1D0-B)**2)*(A/B+B/A)
      F1   = 0.5D0*(1D0-A)**2*WWM *SFAC1
      F2   = 0.5D0*(1D0-B)**2*WWM *SFAC1
      END
 
      SUBROUTINE GBETA0(KEYRED,P1,P2,Q1,Q2,BETA02,BETA01,BETA00)
C     **********************************************************
C Provides elements of beta0,
C for transparency reasons the full reduction of momenta is done.
C     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION P1(*),P2(*),Q1(*),Q2(*)
      DIMENSION PR1(4),PR2(4),QR1(4),QR2(4)
C
      IF(KEYRED.EQ.1) THEN
         CALL REDUM0(P1,P2,Q1,Q2,PR1,PR2,QR1,QR2)
      ELSE
         CALL REDUK0(P1,P2,Q1,Q2,PR1,PR2,QR1,QR2)
      ENDIF
 
      COSTH  = (P1(1)*QR1(1) +P1(2)*QR1(2) +P1(3)*QR1(3))
     $            /SQRT((QR1(1)**2 +QR1(2)**2 +QR1(3)**2)
     $                  *(P1(1)**2  +P1(2)**2  +P1(3)**2))
      SVAR1  = (QR1(4)+QR2(4))**2-(QR1(3)+QR2(3))**2
     $        -(QR1(2)+QR2(2))**2-(QR1(1)+QR2(1))**2
      ANDIS  = BORNV (SVAR1,COSTH )
C     CALL BVIRT0(PR1,PR2,DELS1,DELS2)
C     BETA02 = ANDIS*(1D0+DELS1+DELS2)
C     BETA01 = ANDIS*(1D0+DELS1)
      BETA02 = ANDIS
      BETA01 = ANDIS
      BETA00 = ANDIS
      END
 
      SUBROUTINE SFACH0(P1,P2,PH,SFAC0)
C     *********************************
C CALCULATES SOFT FACTOR FOR REAL SOFT PHOTON.
C     *********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION PH(*),P1(*),P2(*)
      AM2= P1(4)**2-P1(1)**2-P1(2)**2-P1(3)**2
      PK1= P1(4)*PH(4)-P1(1)*PH(1)-P1(2)*PH(2)-P1(3)*PH(3)
      PK2= P2(4)*PH(4)-P2(1)*PH(1)-P2(2)*PH(2)-P2(3)*PH(3)
      PP = P1(4)*P2(4)-P1(1)*P2(1)-P1(2)*P2(2)-P1(3)*P2(3)
      SFAC0  =  2D0*PP/PK1/PK2 -AM2/PK1**2 -AM2/PK2**2
      END
 
      SUBROUTINE GTHET(P1,P2,Q1,Q2,COSTH1,COSTH2)
C     *******************************************
C CALCULATES COSTH1 AND COSTH2 OF BETWEEN BEAM AND FINAL
C FERMION MOMENTA IN FINAL FERMION REST FRAME
C THEY ARE PLUGGED INTO BORN DIFFERENTIAL CROSS XSCTION
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION P1(*),P2(*),Q1(*),Q2(*)
      DIMENSION QQ(4),Q(4),A(4),B(4)
      DO 10 K=1,4
  10  QQ(K)= Q1(K)+Q2(K)
      CALL BOSTDQ(1,QQ,Q1,Q)
      CALL BOSTDQ(1,QQ,P1,A)
      CALL BOSTDQ(1,QQ,P2,B)
      QD  =DSQRT(Q(1)**2+Q(2)**2+Q(3)**2)
      AA  =DSQRT(A(1)**2+A(2)**2+A(3)**2)
      BB  =DSQRT(B(1)**2+B(2)**2+B(3)**2)
      COSTH1= (Q(1)*A(1)+Q(2)*A(2)+Q(3)*A(3))/QD/AA
      COSTH2=-(Q(1)*B(1)+Q(2)*B(2)+Q(3)*B(3))/QD/BB
      END
 
      FUNCTION BORNV(SVARI,COSTHE)
C     ***********************************
C THIS ROUTINE PROVIDES BORN DIFFERENTIAL CROSS SECTION
C a version without COMPLEX*16
C     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON / BHPAR1 / CMS,AMFIN
      COMMON / BHPAR2 / CMSENE,AMEL
      COMMON / WEKINP / AMAZ,GAMMZ,SINW2
      COMMON /BREMSTR/ KEYBRE,KEYPRO
      COMMON /FLAVOUR / IFLEV      
 
      QE= -1D0
      QF= -1D0
      AA= 4D0*SQRT(SINW2*(1D0-SINW2))
      VE= (-1D0+4*SINW2)/AA
      AE= -1D0/AA
      VF= (-1D0+4*SINW2)/AA
      AF= -1D0/AA

      IF(IFLEV.EQ.1.OR.IFLEV.EQ.3) THEN
        QE= 2D0/3D0
        VE= (1D0-8D0/3D0*SINW2)/AA
        AE=  1D0/AA
      ENDIF
      IF(IFLEV.EQ.2.OR.IFLEV.EQ.4) THEN
        QE=-1D0/3D0
        VE= (-1D0+4D0/3D0*SINW2)/AA
        AE=-1D0/AA
      ENDIF

c....no Z0 exchange
      IF(KEYPRO.EQ.2) THEN
         AE=0D0
         AF=0D0
         VE=0D0
         VF=0D0
      ENDIF
c....no photon exchange
      IF(KEYPRO.EQ.3) THEN
         QE=0D0
         QF=0D0
      ENDIF
c....no axial coupling
      IF(KEYPRO.EQ.4) THEN
         AE=0D0
         AF=0D0
      ENDIF
cc....no vector coupling
      IF(KEYPRO.EQ.5) THEN
         VE=0D0
         VF=0D0
      ENDIF
cc...only Z0 axial coupling
      IF(KEYPRO.EQ.6) THEN
         VE=0D0
         VF=0D0
         QE=0D0
         QF=0D0
      ENDIF
cc....only Z0 vector couplig
      IF(KEYPRO.EQ.7) THEN
         AE=0D0
         AF=0D0
         QE=0D0
         QF=0D0
      ENDIF
      

      S = SVARI
      CHI2 =         S**2/((S-AMAZ**2)**2+(GAMMZ*AMAZ)**2)
      RECHI=(S-AMAZ**2)*S/((S-AMAZ**2)**2+(GAMMZ*AMAZ)**2)
      XE= VE**2 +AE**2
      XF= VF**2 +AF**2
      YE= 2*VE*AE
      YF= 2*VF*AF
      FF0= QE**2*QF**2 +2*RECHI*QE*QF*VE*VF +CHI2*XE*XF
      FF1=             +2*RECHI*QE*QF*AE*AF +CHI2*YE*YF
C     BORN    = (1D0+ COSTHE**2)*FF0 +2D0*COSTHE*FF1
      BORN    = (1D0+ COSTHE**2
     1         +4D0*(AMEL**2+AMFIN**2)/S*(1D0-COSTHE**2)
     1         +16*AMEL**2*AMFIN**2/S**2*COSTHE**2)*FF0
     $         +2D0*COSTHE*FF1 

C************
C THIS IS A BIT CRUDE METHOD OF INTRODUCING THRESHOLD BEHAVIOUR
      IF(    SVARI.LE. 4D0*AMFIN**2) THEN
        THRESH=0D0
      ELSEIF(SVARI.LE.16D0*AMFIN**2) THEN
        AMX2=4D0*AMFIN**2/SVARI
        THRESH=SQRT(1D0-AMX2)*(1D0+AMX2/2D0)
      ELSE
        THRESH=1D0
      ENDIF
      BORNV= BORN*THRESH
      END
 
 
      SUBROUTINE TRALQQ(MODE,Q,P,R)
C     *****************************
C BOOST ALONG Z AXIS TO A FRAME WHERE QQ(3)=0
C AND NEXT ALONG TRANSVERSE DIRECTION OF QQ,
C FORTH (MODE = 1) OR BACK (MODE = -1).
C Q MUST BE A TIMELIKE, P MAY BE ARBITRARY.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION Q(*),P(*),R(*)
      DIMENSION QL(4),QT(4)
      QL(4)=Q(4)
      QL(3)=Q(3)
      QL(2)=0D0
      QL(1)=0D0
      CALL BOSTDQ(1,QL,Q,QT)
      IF(MODE.EQ.1) THEN
        CALL BOSTDQ( 1,QL,P,R)
        CALL BOSTDQ( 1,QT,R,R)
      ELSE
        CALL BOSTDQ(-1,QT,P,R)
        CALL BOSTDQ(-1,QL,R,R)
      ENDIF
      END
 
      SUBROUTINE BOSTDQ(MODE,QQ,PP,R)
C     *******************************
C BOOST ALONG ARBITRARY AXIS (BY RONALD KLEISS).
C P BOOSTED INTO R  FROM ACTUAL FRAME TO REST FRAME OF Q
C FORTH (MODE = 1) OR BACK (MODE = -1).
C Q MUST BE A TIMELIKE, P MAY BE ARBITRARY.
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION QQ(*),PP(*),R(*)
      DIMENSION Q(4),P(4)
      DATA  NOUT /6/
      DO 10 K=1,4
      P(K)=PP(K)
   10 Q(K)=QQ(K)
      AMQ =DSQRT(Q(4)**2-Q(1)**2-Q(2)**2-Q(3)**2)
      IF    (MODE.EQ.-1) THEN
         R(4) = (P(1)*Q(1)+P(2)*Q(2)+P(3)*Q(3)+P(4)*Q(4))/AMQ
         FAC  = (R(4)+P(4))/(Q(4)+AMQ)
      ELSEIF(MODE.EQ. 1) THEN
         R(4) =(-P(1)*Q(1)-P(2)*Q(2)-P(3)*Q(3)+P(4)*Q(4))/AMQ
         FAC  =-(R(4)+P(4))/(Q(4)+AMQ)
      ELSE
         WRITE(NOUT,*) ' ++++++++ WRONG MODE IN BOOST3 '
         STOP
      ENDIF
      R(1)=P(1)+FAC*Q(1)
      R(2)=P(2)+FAC*Q(2)
      R(3)=P(3)+FAC*Q(3)
      END
 
      SUBROUTINE GIBEA(CMSENE,P1,P2)
C     ******************************
C GIVEN CMS ENERGY (CMSENE) DEFINES BEAM MOMENTA IN CMS
C     ******************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION P1(*),P2(*)
      AMEL =  0.5111D-3
      BETEL=SQRT(1D0-4D0*AMEL**2/CMSENE**2)
      P1(1)=  0D0
      P1(2)=  0D0
      P1(3)=  CMSENE/2D0*BETEL
      P1(4)=  CMSENE/2D0
      P2(1)=  0D0
      P2(2)=  0D0
      P2(3)= -CMSENE/2D0*BETEL
      P2(4)=  CMSENE/2D0
      END
 
      SUBROUTINE REDUK0(P1,P2,Q1,Q2,PR1,PR2,QR1,QR2)
C     **********************************************
C reduction of momenta for beta0, second one
C I.E. WE MAPP:   P1,P2,Q1,Q2 ==> PR1,PR2,QR1,QR2
C such that  PR1+PR2 = QR1+QR2  and  (QR1+QR2)**2 = (Q1+Q2)**2
C     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION P1(*),P2(*),Q1(*),Q2(*)
      DIMENSION PR1(*),PR2(*),QR1(*),QR2(*)
      DIMENSION PP(4),QQ(4),PX1(4),PX2(4)
C
      DO 20 K=1,4
      PP(K)=P1(K)+P2(K)
 20   QQ(K)=Q1(K)+Q2(K)
      SVAR1 = QQ(4)**2-QQ(3)**2-QQ(2)**2-QQ(1)**2
      SVAR  = PP(4)**2-PP(3)**2-PP(2)**2-PP(1)**2
      VV = 1D0 -SVAR1/SVAR
      IF(VV .GT.1D-5) THEN
C transform all momenta to QMS
         CALL BOSTDQ( 1,QQ,P1 ,PX1)
         CALL BOSTDQ( 1,QQ,P2 ,PX2)
         CALL BOSTDQ( 1,QQ,Q1 ,QR1)
         CALL BOSTDQ( 1,QQ,Q2 ,QR2)
C construct reduced beam momenta PR1,PR2
C start with dilatation of beams
         XLAM= SQRT(SVAR1/SVAR)
         AMEL2=  P1(4)**2-P1(3)**2-P1(2)**2-P1(1)**2
         DO 30 K=1,3
         PX1(K)= PX1(K)*XLAM
 30      PX2(K)= PX2(K)*XLAM
         PX1(4)= SQRT(PX1(1)**2+PX1(2)**2+PX1(3)**2+AMEL2)
         PX2(4)= SQRT(PX2(1)**2+PX2(2)**2+PX2(3)**2+AMEL2)
C then, boost away three-vector part of P1+P2
         DO 35 K=1,4
 35      PP(K)= PX1(K)+PX2(K)
         CALL BOSTDQ( 1,PP,PX1,PR1)
         CALL BOSTDQ( 1,PP,PX2,PR2)
      ELSE
C THE CASE OF NO PHOTON
         DO 50 K=1,4
         PR1(K)=P1(K)
         PR2(K)=P2(K)
         QR1(K)=Q1(K)
   50    QR2(K)=Q2(K)
        ENDIF
      END
 
      SUBROUTINE REDUM0(P1,P2,Q1,Q2,PR1,PR2,QR1,QR2)
C     **********************************************
C REDUCTION OF MOMENTA FOR BETA0
C I.E. WE MAPP:   P1,P2,Q1,Q2 ==> PR1,PR2,QR1,QR2
C SUCH THAT  PR1+PR2 = QR1+QR2  AND  (QR1+QR2)**2 = (Q1+Q2)**2
C THIS IS DONE ESSENTIALLY BY EXCLUDING P-TRAVERSE FROM Q1 AND Q2
C AND BY EXCLUDING P-LONGITUDINAL FROM P1 AND P2
C     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION P1(*),P2(*),Q1(*),Q2(*)
      DIMENSION PR1(*),PR2(*),QR1(*),QR2(*)
      DIMENSION QQ(4)
C
      DO 20 K=1,4
 20   QQ(K)=Q1(K)+Q2(K)
      SVAR1 = QQ(4)**2-QQ(3)**2-QQ(2)**2-QQ(1)**2
      VV = 1D0 -SVAR1/(P1(4)+P2(4))**2
      IF(VV .GT.1D-5) THEN
C TRANSFORM  Q1 AND Q2 TO CMS
         CALL TRALQQ( 1,QQ,Q1 ,QR1)
         CALL TRALQQ( 1,QQ,Q2 ,QR2)
C CONSTRUCT REDUCED BEAM MOMENTA PR1,PR2
         CMSENE=QR1(4)+QR2(4)
         CALL GIBEA(CMSENE,PR1,PR2)
      ELSE
C THE CASE OF NO PHOTON
         DO 50 K=1,4
         PR1(K)=P1(K)
         PR2(K)=P2(K)
         QR1(K)=Q1(K)
   50    QR2(K)=Q2(K)
        ENDIF
      END
 
      SUBROUTINE REDUZ0(QQ,P1,P2,PR1,PR2)
C     ***********************************
C reduction of momenta for beta0, second one
C I.E. WE MAPP:   P1,P2 ==> PR1,PR2
C such that  PR1+PR2 = QQ
C Resulting PRi QRi are in QQ rest frame.
C     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION QQ(4),P1(4),P2(4),PR1(4),PR2(4)
      DIMENSION PP(4),PX1(4),PX2(4),PPX(4)
      DATA EPS1 /1D-15/
C
      DO 20 K=1,4
 20   PP(K)=P1(K)+P2(K)
      IF((PP(1)**2+PP(2)**2+PP(3)**2)/PP(4)**2 .GT. EPS1) THEN
C transform all momenta to QQ rest-frame
         CALL BOSTDQ( 1,QQ,P1 ,PX1)
         CALL BOSTDQ( 1,QQ,P2 ,PX2)
         CALL BOSTDQ( 1,QQ,PP ,PPX)
C transform all momenta to PP rest-frame
         CALL BOSTDQ( 1,PPX,PX1,PX1)
         CALL BOSTDQ( 1,PPX,PX2,PX2)
      ELSE
C do nothing if we are already in PP rest-frame
         DO 23 K=1,4
            PX1(K)=P1(K)
   23       PX2(K)=P2(K)
      ENDIF
C construct reduced beam momenta PR1,PR2
C note: they are understood to be in QQ rest-frame
      SVAR1 = QQ(4)**2-QQ(3)**2-QQ(2)**2-QQ(1)**2
      SVAR  = PP(4)**2-PP(3)**2-PP(2)**2-PP(1)**2
      VV    = 1D0 -SVAR1/SVAR
      IF(ABS(VV).GT. EPS1) THEN
         AMEL2=  P1(4)**2-P1(3)**2-P1(2)**2-P1(1)**2
         PR1(4)= SQRT(SVAR1)/2D0
         PR2(4)= PR1(4)
         PXMOD = SQRT(PX1(1)**2+PX1(2)**2+PX1(3)**2)
         PRMOD = SQRT(PR1(4)**2-AMEL2)
         DO 30 K=1,3
         PR1(K)= PX1(K)/PXMOD*PRMOD
 30      PR2(K)= PX2(K)/PXMOD*PRMOD
      ELSE
         DO 40 K=1,4
         PR1(K)= PX1(K)
 40      PR2(K)= PX2(K)
      ENDIF
      END
 
      SUBROUTINE GTHET0(P1,Q1,COSTH)
C     ******************************
C Calculates CosTh between BEAM and FINAL fermion
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION P1(*),Q1(*)
      COSTH  = (P1(1)*Q1(1) +P1(2)*Q1(2) +P1(3)*Q1(3))
     $            /SQRT((Q1(1)**2 +Q1(2)**2 +Q1(3)**2)
     $                 *(P1(1)**2 +P1(2)**2 +P1(3)**2))
      END
      SUBROUTINE GTHET1(P1,P2,Q1,COSTH1,COSTH2)
C     *****************************************
C Calculates CosTh1 and CosTh2 between BEAM amd FINAL
C fermion momenta in final fermion rest frame Q1(4)+Q2(4)=0
C     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION P1(*),P2(*),Q1(*)
      COSTH1 = (P1(1)*Q1(1) +P1(2)*Q1(2) +P1(3)*Q1(3))
     $            /SQRT((Q1(1)**2 +Q1(2)**2 +Q1(3)**2)
     $                 *(P1(1)**2 +P1(2)**2 +P1(3)**2))
      COSTH2 =-(P2(1)*Q1(1) +P2(2)*Q1(2) +P2(3)*Q1(3))
     $            /SQRT((Q1(1)**2 +Q1(2)**2 +Q1(3)**2)
     $                 *(P2(1)**2 +P2(2)**2 +P2(3)**2))
      END


      SUBROUTINE REDUZ1(QQ,P1,P2,PH,PR1,PR2,PHR)
C     ******************************************
C reduction of 4-momenta for beta1
C           P1,P2,PH ==--> PR1,PR2,PHR
C such that  PR1+PR2 = QQ+PHR
C     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      COMMON / INOUT  / NINP,NOUT,NOUT2
      DIMENSION QQ(4), P1(4), P2(4), PH(4), PR1(4),PR2(4),PHR(4)
      DIMENSION PP(4),QQK(4),PPX(4), PPK(4)
      DIMENSION PX1(4),PX2(4),PHX(4)
      DATA EPS1 /1D-15/
C
      DO 20 K=1,4
      PP(K)   = P1(K)+P2(K)
      PPK(K)  = P1(K)+P2(K)-PH(K)
 20   QQK(K)  = QQ(K)+PH(K)
      SVAR  =  PP(4)**2 -PP(3)**2 -PP(2)**2 -PP(1)**2
      SVAR1 =  QQ(4)**2 -QQ(3)**2 -QQ(2)**2 -QQ(1)**2
      SS1   = PPK(4)**2-PPK(3)**2-PPK(2)**2-PPK(1)**2
      SS2   = QQK(4)**2-QQK(3)**2-QQK(2)**2-QQK(1)**2
      IF((PP(1)**2+PP(2)**2+PP(3)**2)/PP(4)**2 .GT. EPS1) THEN
C transform all momenta to QQ rest-frame
         CALL BOSTDQ( 1,QQ,P1 ,PX1)
         CALL BOSTDQ( 1,QQ,P2 ,PX2)
         CALL BOSTDQ( 1,QQ,PH ,PHX)
         CALL BOSTDQ( 1,QQ,PP ,PPX)
C transform all momenta to PP rest-frame
         CALL BOSTDQ( 1,PPX,PX1,PX1)
         CALL BOSTDQ( 1,PPX,PX2,PX2)
         CALL BOSTDQ( 1,PPX,PHX,PHX)
      ELSE
C do nothing if we are already in PP rest-frame
         DO 23 K=1,4
            PHX(K)=PH(K)
            PX1(K)=P1(K)
   23       PX2(K)=P2(K)
      ENDIF
C construct reduced beam momenta PR1,PR2
C note: they are understood to be in QQ rest-frame
      VV2   = 1D0 - SS2/SVAR
      IF(ABS(VV2).GT. EPS1) THEN
         PK    =  (PX1(4)+PX2(4))*PHX(4)
CCCCC    XLAM= SQRT(SVAR1/SVAR+(PK/SVAR)**2)+PK/SVAR
         XLAM= SQRT(SVAR1/SS1)
         AMEL2=  P1(4)**2-P1(3)**2-P1(2)**2-P1(1)**2
         PXMOD = SQRT(PX1(1)**2+PX1(2)**2+PX1(3)**2)
         PX1(4)= PX1(4)*XLAM
         PX2(4)= PX2(4)*XLAM
CCC      PRMOD = SQRT(PX1(4)**2-AMEL2)
         PRMOD =      PX1(4)**2-AMEL2
         IF(PRMOD.LE.0D0) WRITE(NOUT,*) ' REDUZ1: PRMOD=', PRMOD
         IF(PRMOD.LE.0D0) WRITE(   6,*) ' REDUZ1: PRMOD=', PRMOD
         PRMOD = SQRT(ABS(PRMOD))
         DO 30 K=1,3
         PX1(K)= PX1(K)/PXMOD*PRMOD
 30      PX2(K)= PX2(K)/PXMOD*PRMOD
         DO 31 K=1,4
 31      PHX(K)= PHX(K)*XLAM
      ENDIF
C then, boost away the three-vector part of P1+P2-PH
C that is transform to QQ rest frame
      DO 35 K=1,4
 35   PP(K)= PX1(K)+PX2(K)-PHX(K)
      CALL BOSTDQ( 1,PP,PX1,PR1)
      CALL BOSTDQ( 1,PP,PX2,PR2)
      CALL BOSTDQ( 1,PP,PHX,PHR)
      END




C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
C>>>>>>
C>>>>>   S P I N   A M P L I T U D E S -----Library
C>>>>>>
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      SUBROUTINE AMPLI0(XCROSA)
*     ****************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 XM,XSECTION,S,SUM
      COMMON /MOMCMS0/ P1(4),Q1(4),P2(4),Q2(4)
      COMMON /FRAME/ XMSENE,YMSENE,AMINI,AMFIN
      COMMON / WEKINP / AMAZ,GAMMZ,SINW2

      CMSENE=XMSENE
      
      SUM=DCMPLX(0D0,0D0)
*SUM OVER POSSIBLE HELICITY CONFIGURATIONS
      DO 10 L=1,3,2
      LAM1=2-L
      LAM2=LAM1
      DO 10 K=1,3,2
      LAM3=2-K
      LAM4=LAM3
      S= XM( LAM1,LAM2,LAM3,LAM4)
      SUM=SUM+S*DCONJG(S)
  10  CONTINUE
 
*CROSS SECTION
      XSECTION=SUM
      XCROSA=DBLE(XSECTION)
      END
 
 
*SPIN AMPLITUDE
      FUNCTION XM(L1,L2,L3,L4)
*     *******************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16  HIS ,XM,X
      COMPLEX *16 CP1,C
      COMPLEX *16   SEL ,SPO
      COMMON /MOMCMS0/ P1(4),Q1(4),P2(4),Q2(4)
      COMMON /FRAME/ XMSENE,YMSENE,AMINI,AMFIN
      DIMENSION SEL (2,2),SPO (2,2)
      DIMENSION ZER(4)
 
      S0=XMSENE**2
      DO 5 I=1,4
  5   ZER(I)=0D0

*--------------------------------------------------------
*THE 2 MATRIX SELP,SELP ARE CONSTRACTION OF FINAL
*SPINORS AND ELECTRON BAR SPINOR
*THE 2 MATRIX SPOP,SPOM ARE CONSTRACTION OF FINAL
*SPINORS AND POSITR SPINOR

      C=DCMPLX(1D0,0D0)
      CP1 = C*DELTA(L3,L4)
C please note that there are two possible definitions
C of the conventions for initial-final vertex 

C convetion A :every amplitude in this convention except XMSMIX
      CALL MULTI( L1,P1 ,ZER,C,-C, L3,P2 ,Q2 ,C  , C,SEL ,CP1)
      CALL MULTI( L3,Q2 ,P2 ,C, C, L2,Q1 ,ZER,-C , C,SPO ,C  )
      CALL ADD(SEL ,SPO ,X )
      XM=X*HIS(L1,L3,S0)

C convetion B : in this convention  XMSMIX
C>      CALL MULTI( L1,P1 ,ZER,C,-C, L3,Q2 ,P2 ,C  , C,SEL ,CP1)
C>      CALL MULTI( L3,P2 ,Q2 ,C, C, L2,Q1 ,ZER,-C , C,SPO ,C  )
C>      CALL ADD(SEL ,SPO ,X )
C>      XM=X*HIS(L1,-L3,S0)
 
 
      END

*PROPAGATOR-INITIAL STATE
      FUNCTION PROPIN(P1,PH)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION P1(4),PH(4)
 
      PHPH=PH(4)**2-PH(1)**2-PH(2)**2-PH(3)**2
      P1PH=P1(4)*PH(4)-P1(1)*PH(1)-P1(2)*PH(2)-P1(3)*PH(3)
      PROPIN=1D0/(-2D0*P1PH+PHPH)
 
      END
 
*PROPAGATOR-FINAL STATE
      FUNCTION PROPFIN(P1,PH)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION P1(4),PH(4)
 
      PHPH=PH(4)**2-PH(1)**2-PH(2)**2-PH(3)**2
      P1PH=P1(4)*PH(4)-P1(1)*PH(1)-P1(2)*PH(2)-P1(3)*PH(3)
      PROPFIN=1D0/( 2D0*P1PH+PHPH)
 
      END
*PROPAGATOR
      FUNCTION PROP( P1,PH)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION P1(4),PH(4)
 
      PHPH=PH(4)**2-PH(1)**2-PH(2)**2-PH(3)**2
      P1PH=P1(4)*PH(4)-P1(1)*PH(1)-P1(2)*PH(2)-P1(3)*PH(3)
      PROP=1D0/(-2D0*P1PH+PHPH)
 
      END
*ILOCZYN SCALARNY VEKTORA POL. FOTONU I PEDU
      FUNCTION EP(LEPS,P11,P12)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   SPM,EP
      COMMON / MOMSET / P1(4),Q1(4),P2(4),Q2(4),PH(4)
      COMMON /FOTON/ ARBIT(4)
      DIMENSION P11(4),P12(4)
 
 
      EP=     SPM(LEPS,PH,P11)*SPM(-LEPS,P11,ARBIT)
     $       +SPM(LEPS,PH,P12)*SPM(-LEPS,P12,ARBIT)
 
      END
*FUNCTION OF SPINOR PRODUCT
      FUNCTION SPM(LAM,P1,P2)
*     ********************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 SPLUS,SMINS,SPM
      DIMENSION P1(4),P2(4)
 
 
      IF (P1(4).LT.1D-15) THEN
      SPM=DCMPLX(0D0,0D0)
      ELSE IF (P2(4).LT.1D-15) THEN
      SPM=DCMPLX(0D0,0D0)
      ELSE
      SPM=DELTA(LAM, 1)*SPLUS(P1,P2)
     $   +DELTA(LAM,-1)*SMINS(P1,P2)
      ENDIF
 
      END
 
*ILOCZYN SCALARNY VEKTORA POL. FOTONU I PEDU
      FUNCTION EPP(LEPS,P11,P12,PH)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   SPM,EPP
      COMMON /FOTON/ ARBIT(4)
      DIMENSION P11(4),P12(4),PH(4)
 
 
      EPP=    SPM(LEPS,PH,P11)*SPM(-LEPS,P11,ARBIT)
     $       +SPM(LEPS,PH,P12)*SPM(-LEPS,P12,ARBIT)
 
      END
 
      SUBROUTINE ILOCZ(SEL,SPO,S)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   SEL,SPO,S
      DIMENSION SEL(2,2),SPO(2,2),S(2,2)
 
* MULTIPLE MATRIX S =SEL*SPO
      S(1,1)=SEL(1,1)*SPO(1,1)+SEL(1,2)*SPO(2,1)
      S(1,2)=SEL(1,1)*SPO(1,2)+SEL(1,2)*SPO(2,2)
      S(2,1)=SEL(2,1)*SPO(1,1)+SEL(2,2)*SPO(2,1)
      S(2,2)=SEL(2,1)*SPO(1,2)+SEL(2,2)*SPO(2,2)
 
      END

      SUBROUTINE  DODAJ4(S1,S2,S3,S4,S)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   S1,S2,S3,S4,S
      DIMENSION S1(2,2),S2(2,2),S3(2,2),S(2,2),S4(2,2)
 
* ADDING   MATRIX S =S1 +S2 +S3+S4
      S(1,1)=S1(1,1)+S2(1,1)+S3(1,1) +S4(1,1)
      S(1,2)=S1(1,2)+S2(1,2)+S3(1,2) +S4(1,2)
      S(2,1)=S1(2,1)+S2(2,1)+S3(2,1) +S4(2,1)
      S(2,2)=S1(2,2)+S2(2,2)+S3(2,2) +S4(2,2)
 
      END
 
      SUBROUTINE  DODAJ3(S1,S2,S3,S)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   S1,S2,S3,S
      DIMENSION S1(2,2),S2(2,2),S3(2,2),S(2,2)
 
* ADDING   MATRIX S =S1 +S2 +S3
      S(1,1)=S1(1,1)+S2(1,1)+S3(1,1)
      S(1,2)=S1(1,2)+S2(1,2)+S3(1,2)
      S(2,1)=S1(2,1)+S2(2,1)+S3(2,1)
      S(2,2)=S1(2,2)+S2(2,2)+S3(2,2)
 
      END
 
      SUBROUTINE  DODAJ(SEL,SPO,S)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   SEL,SPO,S
      DIMENSION SEL(2,2),SPO(2,2),S(2,2)
 
* ADDING   MATRIX S =SEL+SPO
      S(1,1)=SEL(1,1)+SPO(1,1)
      S(1,2)=SEL(1,2)+SPO(1,2)
      S(2,1)=SEL(2,1)+SPO(2,1)
      S(2,2)=SEL(2,2)+SPO(2,2)
 
      END
      SUBROUTINE ADD4(SEL,SPH ,SFI,SPO ,X)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   SEL,S,SS,X,SPH,SFI ,SPO
      DIMENSION SEL(2,2),S(2,2),SPO(2,2),SFI(2,2),SS(2,2),SPH(2,2)
 
* MULTIPLE MATRIX S =SEL*SPH
      CALL ILOCZ(SEL,SPH,S)
* MULTIPLE MATRIX SS=S *SFI
      CALL ILOCZ(S,SFI,SS)
* MULTIPLE MATRIX S=SS*SPO
      CALL ILOCZ(SS,SPO ,S)
*CONSTRACTION TO THE SCALAR OBJECT
      X=S (1,1)+S (1,2)+S (2,1)+S (2,2)
 
      END
 
      SUBROUTINE ADD3(SEL,SPH ,SFI,X)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   SEL,S,SS,X,SPH,SFI
      DIMENSION SEL(2,2),S(2,2),SFI(2,2),SS(2,2),SPH(2,2)
 
* MULTIPLE MATRIX S =SEL*SPH
      CALL ILOCZ(SEL,SPH,S)
* MULTIPLE MATRIX SS=S *SFI
      CALL ILOCZ(S,SFI,SS)
*CONSTRACTION TO THE SCALAR OBJECT
      X=SS(1,1)+SS(1,2)+SS(2,1)+SS(2,2)
 
      END
 
      SUBROUTINE ADD1(SEL,SF,SPO,X)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   SEL,SPO,S,X,SF,SS
      DIMENSION SEL(2,2),SPO(2,2),S(2,2),SF(2,2),SS(2,2)
 
* MULTIPLE MATRIX S =SEL*SF
      CALL ILOCZ(SEL,SF ,S)
* MULTIPLE MATRIX SS=S  *SPO
      CALL ILOCZ(S  ,SPO,SS)
*CONSTRACTION TO THE SCALAR OBJECT
      X=SS(1,1)+SS(1,2)+SS(2,1)+SS(2,2)
 
      END
 
      SUBROUTINE ADD (SEL,SF,X)
*     **************************************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16   SEL,S,X,SF
      DIMENSION SEL(2,2),S(2,2),SF(2,2)
 
* MULTIPLE MATRIX S =SEL*SF
      CALL ILOCZ(SEL,SF ,S)
*CONSTRACTION TO THE SCALAR OBJECT
      X=S (1,1)+S (1,2)+S (2,1)+S (2,2)
 
      END
 
 
*PRODUCT OF VB(L1,P1,Q1,A1,B1)*V(L2,P2,Q2,A2,B2)
      SUBROUTINE MULTI(L1,P1,Q1,A1,B1,L2,P2,Q2,A2,B2,SS,C)
*     *******************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 A1,A2,SS,C,B1,B2,SSPM
      DIMENSION P1(4),P2(4),Q1(4),Q2(4),SS(2,2)
 
 
      A1=DCONJG(A1)
 
      SS(1,1)=A1*A2*SSPM( L1, L2,P1,P2)*C
      SS(1,2)=A1*B2*SSPM( L1,-L2,P1,Q2)*C
      SS(2,1)=B1*A2*SSPM(-L1, L2,Q1,P2)*C
      SS(2,2)=B1*B2*SSPM(-L1,-L2,Q1,Q2)*C
 
      END
 
*FUNCTION DIRAC DELTA FOR INTEGER ARGUMENTS
      FUNCTION DELTA(L1,L2)
*    ****************************************
      IMPLICIT REAL*8(A-H,O-Z)
 
      N=(1+L1*L2)
      IF (N.EQ.2) DELTA=1D0
        IF (N.EQ.0) DELTA=0D0
      END
 
* DEFINE COEFFICIENT FOR MASSIVE FERMIONS
      FUNCTION COEF(P,LAM)
*     *******************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 SPM,COEF
      DIMENSION P(4),P1(4),P2(4)
      COMMON / BHPAR2 / CMSENE,AMEL
 
*LIGHT LIKE MOMENTA P1,P2 ARE CONSTRUCTED, P1+P2=P
      CALL MOMENTA(P,P1,P2)
 
      IF (P1(4).LT.1D-8 ) THEN
      COEF=DCMPLX(1D0,0D0)
      ELSE IF (P2(4).LT.1D-8 ) THEN
      COEF=DCMPLX(1D0,0D0)
      ELSE IF ( P(4).LT.1D-8 ) THEN
      COEF=DCMPLX(1D0,0D0)
      ELSE
      AM=DSQRT(P(4)**2-P(1)**2-P(2)**2-P(3)**2)
      COEF=SPM(LAM,P1,P2)/AM
      ENDIF
 
      END
 
*DEFINE LIGHT=LIKE MOMENTA FOR MASIVE FERMIONS
      SUBROUTINE MOMENTA(P,P1,P2)
*     *******************************
      IMPLICIT REAL*8(A-H,O-Z)
      DIMENSION P(4),P1(4),P2(4)
      COMMON / BHPAR2 / CMSENE,AMEL
 
      PM=DSQRT(P(1)**2+P(2)**2+P(3)**2)
      HI1=1/2D0*(P(4)+PM)
      HI2=1/2D0*(P(4)-PM)
      DO 10 I=1,3
      P1(I)= HI1*P(I)/PM
 10   P2(I)=-HI2*P(I)/PM
      P1(4)=HI1
      P2(4)=HI2
 
      END
*FUNCTION OF SPINOR PRODUCT OF MASSIVE PARTICLES
      FUNCTION SSPM(L1,L2,P1,P2)
*     ********************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 SPLUS,SMINS,SSPM
      DIMENSION P1(4),P2(4)
 
 
      IF (P1(4).LT.1D-15) THEN
      SSPM=(0D0,0D0)
      ELSE IF (P2(4).LT.1D-15) THEN
      SSPM=(0D0,0D0)
      ELSE
      R1=P1(4)-P1(3)
      R2=P2(4)-P2(3)
      AM1=(P1(4)**2-P1(1)**2-P1(2)**2-P1(3)**2)
      AM2=(P2(4)**2-P2(1)**2-P2(2)**2-P2(3)**2)
      IF (AM1.GT.0D0) THEN
      AM1=DSQRT(AM1)
      IF (ABS(R1).LT.1D-3) AM1=-AM1
      ELSE
      AM1=0D0
      ENDIF
      IF (AM2.GT.0D0) THEN
      AM2=DSQRT(AM2)
      IF (ABS(R2).LT.1D-3) AM2=-AM2
      ELSE
      AM2=0D0
      ENDIF
      ETA2=DSQRT(P2(4)-P2(1))
      ETA1=DSQRT(P1(4)-P1(1))
      SSPM=DELTA(L1, 1)*DELTA(L2,-1)*SPLUS(P1,P2)
     $   +DELTA(L1,-1)*DELTA(L2, 1)*SMINS(P1,P2)
     $   +(DELTA(L1, 1)*DELTA(L2, 1)+DELTA(L1,-1)*DELTA(L2,-1))
     $   *(AM1*ETA2/ETA1+AM2*ETA1/ETA2)
 
      ENDIF
 
      END
 
*SPINOR PRODUCT
*FROM KLEISS, Z.PHYS.C33.433-443 (1987)
      FUNCTION SPLUS(P1,P2)
*     ********************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 SPLUS,X,Y
      DIMENSION P1(4),P2(4)
 
      X=DCMPLX(P1(2),P1(3))
      Y=DCMPLX(P2(2),P2(3))
      SPLUS=X*DSQRT(P2(4)-P2(1))/DSQRT(P1(4)-P1(1))
     $     -Y*DSQRT(P1(4)-P1(1))/DSQRT(P2(4)-P2(1))
      END
 
*SPINOR PRODUCT
*FROM KLEISS, Z.PHYS.C33.433-443 (1987)
      FUNCTION SMINS(P1,P2)
*     ********************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 SPLUS,SMINS
      DIMENSION P1(4),P2(4)
 
      SMINS=-DCONJG(SPLUS(P1,P2))
      END
 
*RADIATION FACTOR TO INITIAL STATE
*FROM KLEISS, Z.PHYS.C33.433-443 (1987)
      FUNCTION VINI(NUMBER)
*     ***************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 SPLUS,SMINS,VINI
      COMMON / MOMSET / P1(4),Q1(4),P2(4),Q2(4),PH(4)
 
      VINI=SMINS(Q2,P2)/(SPLUS(PH,P1)*SPLUS(Q1,PH))
 
      END
*RADIATION FACTOR TO FINAL STATE
*FROM KLEISS, Z.PHYS.C33.433-443 (1987)
      FUNCTION VFIN(NUMBER)
*     ***************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX*16 SPLUS,SMINS,VFIN
      COMMON / MOMSET / P1(4),Q1(4),P2(4),Q2(4),PH(4)
 
      VFIN=SMINS(Q1,P1)/(SPLUS(PH,P2)*SPLUS(Q2,PH))
 
      END
 
*Z0+PHOTON REDUCED PROPAGATOR IN CHANEL S
*FROM BOHM,DENNIER,HOLLIK,NUCL.PHYS.B304(1988),687
      FUNCTION HIS(NI1,NI2,X)
*     ***************************
      IMPLICIT REAL*8(A-H,O-Z)
      COMPLEX *16 Z,HIS
      COMMON / WEKINP / AMAZ,GAMMZ,SINW2
      COMMON /FLAVOUR/ IFLEV 
      COMMON /BREMSTR/ KEYBRE,KEYPRO    
      COMMON /FRAME/ XMSENE,YMSENE,AMINI,AMFIN

      QE=-1D0
      QF=-1D0
      AA= 4D0*DSQRT(SINW2*(1D0-SINW2))
      VE= (-1D0+4*SINW2)/AA
      AE=-1D0/AA
      VF= (-1D0+4*SINW2)/AA
      AF=-1D0/AA
      IF(IFLEV.EQ.1.OR.IFLEV.EQ.3) THEN
        QE=2D0/3D0
        VE= (1D0-8D0/3D0*SINW2)/AA
        AE=  1D0/AA
      ENDIF
      IF(IFLEV.EQ.2.OR.IFLEV.EQ.4) THEN
        QE=-1D0/3D0
        VE= (-1D0+4D0/3D0*SINW2)/AA
        AE=-1D0/AA
      ENDIF

c....no Z0 exchange
      IF(KEYPRO.EQ.2) THEN
         AE=0D0
         AF=0D0
         VE=0D0
         VF=0D0
      ENDIF
c....no photon exchange
      IF(KEYPRO.EQ.3) THEN
         QE=0D0
         QF=0D0
      ENDIF
c....no axial coupling
      IF(KEYPRO.EQ.4) THEN
         AE=0D0
         AF=0D0
      ENDIF
cc....no vector coupling
      IF(KEYPRO.EQ.5) THEN
         VE=0D0
         VF=0D0
      ENDIF
cc....only Z0 axial coupling
      IF(KEYPRO.EQ.6) THEN
         VE=0D0
         VF=0D0
         QE=0D0
         QF=0D0
      ENDIF
cc....only Z0 vector couplig
      IF(KEYPRO.EQ.7) THEN
         AE=0D0
         AF=0D0
         QE=0D0
         QF=0D0
      ENDIF

 
      BZ0RE=(X-AMAZ**2)
     $      /((X-AMAZ**2)**2+GAMMZ**2*AMAZ**2)
      BZ0IM=-GAMMZ*AMAZ
     $      /((X-AMAZ**2)**2+GAMMZ**2*AMAZ**2)
      Z=DCMPLX(BZ0RE,BZ0IM)
      HIS=(QE*QF/X+(VE+NI1*AE)*(VF+NI2*AF)*Z)
C************
C THIS IS A BIT CRUDE METHOD OF INTRODUCING THRESHOLD BEHAVIOUR
      IF(  YMSENE**2.LE. 4D0*AMFIN**2) THEN
        THRESH=0D0
      ELSEIF(YMSENE**2.LE.16D0*AMFIN**2) THEN
        AMX2=4D0*AMFIN**2/YMSENE**2
        THRESH=SQRT(1D0-AMX2)*(1D0+AMX2/2D0)
      ELSE
        THRESH=1D0
      ENDIF
      HIS= HIS*DSQRT(THRESH)

      END
      SUBROUTINE DUMPH(FMOM)
      IMPLICIT REAL*8(A-H,O-Z)
**    ************************
      COMMON / INOUT  / NINP,NOUT,NOUT2   
      DIMENSION FMOM(4)
      XMASS=FMOM(4)**2-FMOM(1)**2-FMOM(2)**2-FMOM(3)**2
      IF(XMASS.GT.0.D0) XMASS=SQRT(XMASS)
      WRITE(NOUT,10) FMOM,XMASS
 10   FORMAT(1X,5(1X,F13.8))
      END  

C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
C>>>>>>>>>
C----------------------------------------------------------------C
C --------  LIBRARY ORGINATING FROM BHLUMI2.01... TAUOLA... -----C
C----------------------------------------------------------------C
C>>>>>>>>>
C>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
      SUBROUTINE RENHIE(ID,FACT,NB)
C     ****************************
C errors taken into account
C     INTRODUCES HISTOGRAM NORMALISATION
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION X(400),XE(400)
      FAC=FACT
      CALL GUNPAK(ID, X,'    ',1)
      CALL GUNPAK(ID,XE,'ERRO',1)
      CALL GRESET(ID,' ')
      SUM=0D0
      DO 10 I=1,NB
   10 SUM=SUM+X(I)
      IF(SUM.EQ.0D0) RETURN
      IF(FAC.EQ.0D0) FAC=1D0/SUM
      DO 20 I=1,NB
      X(I) = X(I)*FAC
      XE(I)=XE(I)*FAC
   20 CONTINUE
      CALL GPAK( ID,X )
      CALL GPAKE(ID,XE)
      
      END
      SUBROUTINE LICFAC(ID,FACT,NB)
C     ****************************
C errors taken into account
C     INTRODUCES HISTOGRAM NORMALISATION
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION X(400),XE(400)

      CALL GUNPAK(ID, X,'    ',1)
      CALL GUNPAK(ID,XE,'ERRO',1)
      CALL GRESET(ID,' ')
      SUM=0D0
      DO 10 I=1,NB
   10 SUM=SUM+X(I)
      IF(SUM.EQ.0D0) RETURN
      FACT=1D0/SUM

      CALL GPAK( ID,X )
      CALL GPAKE(ID,XE)
      
      END

      SUBROUTINE CUMHI3(ID,NB,NEVT,XCRU)
C     **********************************
C cumulates histogram content starting from underflow
*     ***********************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION X(400),ER(400)
C=====((((
      SWT  = GI (ID,0)
      SSWT = GIE(ID,0)**2
      DO 100 I=1,NB
      SWT   = SWT + GI (ID,I)
      SSWT  = SSWT+ GIE(ID,I)**2
      XSEC  = SWT*(XCRU/NEVT)
C note NEVT in error calc. is for ethe ntire sample related
C to XCRU !!!! including zero weight events !
      if(swt.eq.0d0) then
      errel = 0d0
      else
      ERREL = SQRT(ABS(SSWT/SWT**2-1D0/FLOAT(NEVT)))
      endif
      X(I)  = XSEC
      ER(I) = XSEC*ERREL
 100  CONTINUE
      CALL GPAK (ID  ,X)
      CALL GPAKE(ID  ,ER)
      CALL GIDOPT(ID,'ERRO')
      CALL GPRINT(ID)
C=====((((
      END
      SUBROUTINE SPHERD(R,X)
C ----------------------------------------------------------------------
C GENERATES UNIFORMLY THREE-VECTOR X ON SPHERE  OF RADIUS R
C DOUBLE PRECISON VERSION OF SPHERA
C ----------------------------------------------------------------------
      REAL*8  R,X(4),PI,COSTH,SINTH
      REAL*8 RRR(2)
      DATA PI /3.141592653589793238462643D0/
C
      CALL VARRAN(RRR,2)
      COSTH=-1+2*RRR(1)
      SINTH=SQRT(1 -COSTH**2)
      X(1)=R*SINTH*COS(2*PI*RRR(2))
      X(2)=R*SINTH*SIN(2*PI*RRR(2))
      X(3)=R*COSTH
      RETURN
      END

      SUBROUTINE ROTPOD(THET,PHI,PP)
C ----------------------------------------------------------------------
C
C     rotation on the sphere
C ----------------------------------------------------------------------
      REAL *8  PP(4)
C
      CALL ROTOD2(THET,PP,PP)
      CALL ROTOD3( PHI,PP,PP)
      RETURN
      END

C           **************************************************
C           *       **********************************       *
C           *       *      *******************       *       *
C           *       *      *                 *       *       *
C           *       *      *   B H L L I B   *       *       *
C           *       *      *                 *       *       *
C           *       *      *******************       *       *
C           *       **********************************       *
C           **************************************************
C
C BOOST ALONG X AXIS, EXE=EXP(ETA), ETA= HIPERBOLIC VELOCITY.
      SUBROUTINE BOSTD1(EXE,PVEC,QVEC)
C     ********************************
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 PVEC(4),QVEC(4),RVEC(4)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      RPL=RVEC(4)+RVEC(1)
      RMI=RVEC(4)-RVEC(1)
      QPL=RPL*EXE
      QMI=RMI/EXE
      QVEC(2)=RVEC(2)
      QVEC(3)=RVEC(3)
      QVEC(1)=(QPL-QMI)/2
      QVEC(4)=(QPL+QMI)/2
      END

C BOOST ALONG Z AXIS, EXE=EXP(ETA), ETA= HIPERBOLIC VELOCITY.
      SUBROUTINE BOSTD3(EXE,PVEC,QVEC)
C     ********************************
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 PVEC(4),QVEC(4),RVEC(4)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      RPL=RVEC(4)+RVEC(3)
      RMI=RVEC(4)-RVEC(3)
      QPL=RPL*EXE
      QMI=RMI/EXE
      QVEC(1)=RVEC(1)
      QVEC(2)=RVEC(2)
      QVEC(3)=(QPL-QMI)/2
      QVEC(4)=(QPL+QMI)/2
      END

      SUBROUTINE ROTOD1(PH1,PVEC,QVEC)
C     ********************************
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 PVEC(4),QVEC(4),RVEC(4)
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)=RVEC(1)
      QVEC(2)= CS*RVEC(2)-SN*RVEC(3)
      QVEC(3)= SN*RVEC(2)+CS*RVEC(3)
      QVEC(4)=RVEC(4)
      END

      SUBROUTINE ROTOD2(PH1,PVEC,QVEC)
C     ********************************
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 PVEC(4),QVEC(4),RVEC(4)
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)= CS*RVEC(1)+SN*RVEC(3)
      QVEC(2)=RVEC(2)
      QVEC(3)=-SN*RVEC(1)+CS*RVEC(3)
      QVEC(4)=RVEC(4)
      END

      SUBROUTINE ROTOD3(PH1,PVEC,QVEC)
C     ********************************
      IMPLICIT REAL*8(A-H,O-Z)
      REAL*8 PVEC(4),QVEC(4),RVEC(4)
      PHI=PH1
      CS=COS(PHI)
      SN=SIN(PHI)
      DO 10 I=1,4
  10  RVEC(I)=PVEC(I)
      QVEC(1)= CS*RVEC(1)-SN*RVEC(2)
      QVEC(2)= SN*RVEC(1)+CS*RVEC(2)
      QVEC(3)=RVEC(3)
      QVEC(4)=RVEC(4)
      END

      FUNCTION ANGFI(X,Y)
C     *******************
* CALCULATES ANGLE IN (0,2*PI) RANGE OUT OF X-Y
*     ***********************
      IMPLICIT REAL*8(A-H,O-Z)
      DATA PI /3.1415926535897932D0/

      IF(ABS(Y).LT.ABS(X)) THEN
        THE=ATAN(ABS(Y/X))
        IF(X.LE.0D0) THE=PI-THE
      ELSE
        THE=ACOS(X/SQRT(X**2+Y**2))
      ENDIF
      IF(Y.LT.0D0) THE=2D0*PI-THE
      ANGFI=THE
      END
      SUBROUTINE MARRAN(RVEC,LENV)
C =======================S. JADACH===================================
C == This commes from F. James, The name of RANMAR is changed to   ==
C == MARRAN in order to avoid interference with the version        ==
C == already in use and the public library version (if present).   ==
C ==      THIS IS THE ONLY MODIFICATION !!!!                       ==
C ========================S. JADACH==================================
C Universal random number generator proposed by Marsaglia and Zaman
C in report FSU-SCRI-87-50
C        modified by F. James, 1988 and 1989, to generate a vector
C        of pseudorandom numbers RVEC of length LENV, and to put in
C        the COMMON block everything needed to specify currrent state,
C        and to add input and output entry points RMARIN, RMARUT.
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C!!!  Calling sequences for RANMAR:                                  ++
C!!!      CALL RANMAR (RVEC, LEN)   returns a vector RVEC of LEN     ++
C!!!                   32-bit random floating point numbers between  ++
C!!!                   zero and one.                                 ++
C!!!      CALL RMARIN(I1,N1,N2)   initializes the generator from one ++
C!!!                   32-bit integer I1, and number counts N1,N2    ++
C!!!                  (for initializing, set N1=N2=0, but to restart ++
C!!!                    a previously generated sequence, use values  ++
C!!!                    output by RMARUT)                            ++
C!!!      CALL RMARUT(I1,N1,N2)   outputs the value of the original  ++
C!!!                  seed and the two number counts, to be used     ++
C!!!                  for restarting by initializing to I1 and       ++
C!!!                  skipping N2*100000000+N1 numbers.              ++
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      DIMENSION RVEC(*)
      COMMON/RASET1/U(97),C,I97,J97
      PARAMETER (MODCNS=1000000000)
      SAVE CD, CM, TWOM24, NTOT, NTOT2, IJKL
      DATA NTOT,NTOT2,IJKL/-1,0,0/
C
      IF (NTOT .GE. 0)  GO TO 50
C
C        Default initialization. User has called RANMAR without RMARIN.
      IJKL = 54217137
      NTOT = 0
      NTOT2 = 0
      KALLED = 0
      GO TO 1
C
      ENTRY      RMARIN(IJKLIN, NTOTIN,NTOT2N)
C         Initializing routine for RANMAR, may be called before
C         generating pseudorandom numbers with RANMAR. The input
C         values should be in the ranges:  0<=IJKLIN<=900 OOO OOO
C                                          0<=NTOTIN<=999 999 999
C                                          0<=NTOT2N<<999 999 999!
C To get the standard values in Marsaglia's paper, IJKLIN=54217137
C                                            NTOTIN,NTOT2N=0
      IJKL = IJKLIN
      NTOT = MAX(NTOTIN,0)
      NTOT2= MAX(NTOT2N,0)
      KALLED = 1
C          always come here to initialize
    1 CONTINUE
      IJ = IJKL/30082
      KL = IJKL - 30082*IJ
      I = MOD(IJ/177, 177) + 2
      J = MOD(IJ, 177)     + 2
      K = MOD(KL/169, 178) + 1
      L = MOD(KL, 169)
      WRITE(6,'(A,5I10)')
     $ ' MARran INITIALIZED: IJ,KL,IJKL,NTOT,NTOT2=',IJ,KL,IJKL,NTOT,NTO
CCC      PRINT '(A,4I10)', '   I,J,K,L= ',I,J,K,L
      DO 2 II= 1, 97
      S = 0.
      T = .5
      DO 3 JJ= 1, 24
         M = MOD(MOD(I*J,179)*K, 179)
         I = J
         J = K
         K = M
         L = MOD(53*L+1, 169)
         IF (MOD(L*M,64) .GE. 32)  S = S+T
    3    T = 0.5*T
    2 U(II) = S
      TWOM24 = 1.0
      DO 4 I24= 1, 24
    4 TWOM24 = 0.5*TWOM24
      C  =   362436.*TWOM24
      CD =  7654321.*TWOM24
      CM = 16777213.*TWOM24
      I97 = 97
      J97 = 33
C       Complete initialization by skipping
C            (NTOT2*MODCNS + NTOT) random numbers
      DO 45 LOOP2= 1, NTOT2+1
      NOW = MODCNS
      IF (LOOP2 .EQ. NTOT2+1)  NOW=NTOT
      IF (NOW .GT. 0)  THEN
        WRITE(6,'(A,I15)') ' RMARIN SKIPPING OVER ',NOW
       DO 40 IDUM = 1, NTOT
       UNI = U(I97)-U(J97)
       IF (UNI .LT. 0.)  UNI=UNI+1.
       U(I97) = UNI
       I97 = I97-1
       IF (I97 .EQ. 0)  I97=97
       J97 = J97-1
       IF (J97 .EQ. 0)  J97=97
       C = C - CD
       IF (C .LT. 0.)  C=C+CM
   40  CONTINUE
      ENDIF
   45 CONTINUE
      IF (KALLED .EQ. 1)  RETURN
C
C          Normal entry to generate LENV random numbers
   50 CONTINUE
      DO 100 IVEC= 1, LENV
      UNI = U(I97)-U(J97)
      IF (UNI .LT. 0.)  UNI=UNI+1.
      U(I97) = UNI
      I97 = I97-1
      IF (I97 .EQ. 0)  I97=97
      J97 = J97-1
      IF (J97 .EQ. 0)  J97=97
      C = C - CD
      IF (C .LT. 0.)  C=C+CM
      UNI = UNI-C
      IF (UNI .LT. 0.) UNI=UNI+1.
      RVEC(IVEC) = UNI
C             Replace exact zeros by uniform distr. *2**-24
         IF (UNI .EQ. 0.)  THEN
         ZUNI = TWOM24*U(2)
C             An exact zero here is very unlikely, but let's be safe.
         IF (ZUNI .EQ. 0.) ZUNI= TWOM24*TWOM24
         RVEC(IVEC) = ZUNI
         ENDIF
  100 CONTINUE
      NTOT = NTOT + LENV
         IF (NTOT .GE. MODCNS)  THEN
         NTOT2 = NTOT2 + 1
         NTOT = NTOT - MODCNS
         ENDIF
      RETURN
C           Entry to output current status
      ENTRY RMARUT(IJKLUT,NTOTUT,NTOT2T)
      IJKLUT = IJKL
      NTOTUT = NTOT
      NTOT2T = NTOT2
      RETURN
      END

      SUBROUTINE RCARRY(RVEC,LENV)
C         Add-and-carry random number generator proposed by
C         Marsaglia and Zaman in SIAM J. Scientific and Statistical
C             Computing, to appear probably 1990.
C         modified with enhanced initialization by F. James, 1990
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C!!!  Calling sequences for RCARRY:                                  ++
C!!!      CALL RCARRY (RVEC, LEN)   returns a vector RVEC of LEN     ++
C!!!                   32-bit random floating point numbers between  ++
C!!!                   zero and one.                                 ++
C!!!      CALL RCARGO(INT)     initializes the generator from one    ++
C!!!                   32-bit integer INT                            ++
C!!!      CALL RCARIN(IVEC)    restarts the generator from vector    ++
C!!!                   IVEC of 25 32-bit integers (see RCARUT)       ++
C!!!      CALL RCARUT(IVEC)    outputs the current values of the 25  ++
C!!!                 32-bit integer seeds, to be used for restarting ++
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      DIMENSION RVEC(LENV)
      DIMENSION SEEDS(24), ISEEDS(24), ISDEXT(25)
      PARAMETER (TWOP12=4096.)
      PARAMETER (ITWO24=2**24, ICONS=2147483563)
      SAVE NOTYET, I24, J24, CARRY, SEEDS, TWOM24
      LOGICAL NOTYET
      DATA NOTYET/.TRUE./
      DATA I24,J24,CARRY/24,10,0./
C
C              Default Initialization by Multiplicative Congruential
      IF (NOTYET) THEN
         NOTYET = .FALSE.
         JSEED = 314159265
         WRITE(6,'(A,I12)') ' RCARRY DEFAULT INITIALIZATION: ',JSEED
            TWOM24 = 1.
         DO 25 I= 1, 24
            TWOM24 = TWOM24 * 0.5
         K = JSEED/53668
         JSEED = 40014*(JSEED-K*53668) -K*12211
         IF (JSEED .LT. 0)  JSEED = JSEED+ICONS
         ISEEDS(I) = MOD(JSEED,ITWO24)
   25    CONTINUE
         DO 50 I= 1,24
         SEEDS(I) = REAL(ISEEDS(I))*TWOM24
   50    CONTINUE
         I24 = 24
         J24 = 10
         CARRY = 0.
         IF (SEEDS(24) .LT. SEEDS(14)) CARRY = TWOM24
      ENDIF
C
C          The Generator proper: "Subtract-with-borrow",
C          as proposed by Marsaglia and Zaman,
C          Florida State University, March, 1989
C
      DO 100 IVEC= 1, LENV
      UNI = SEEDS(I24) - SEEDS(J24) - CARRY
      IF (UNI .LT. 0.)  THEN
         UNI = UNI + 1.0
         CARRY = TWOM24
      ELSE
         CARRY = 0.
      ENDIF
      SEEDS(I24) = UNI
      I24 = I24 - 1
      IF (I24 .EQ. 0)  I24 = 24
      J24 = J24 - 1
      IF (J24 .EQ. 0)  J24 = 24
      RVEC(IVEC) = UNI
  100 CONTINUE
      RETURN
C           Entry to input and float integer seeds from previous run
      ENTRY RCARIN(ISDEXT)
         TWOM24 = 1.
         DO 195 I= 1, 24
  195    TWOM24 = TWOM24 * 0.5
      WRITE(6,'(A)') ' FULL INITIALIZATION OF RCARRY WITH 25 INTEGERS:'
      WRITE(6,'(5X,5I12)') ISDEXT
      DO 200 I= 1, 24
      SEEDS(I) = REAL(ISDEXT(I))*TWOM24
  200 CONTINUE
      CARRY = REAL(MOD(ISDEXT(25),10))*TWOM24
      ISD = ISDEXT(25)/10
      I24 = MOD(ISD,100)
      ISD = ISD/100
      J24 = ISD
      RETURN
C                    Entry to ouput seeds as integers
      ENTRY RCARUT(ISDEXT)
      DO 300 I= 1, 24
         ISDEXT(I) = INT(SEEDS(I)*TWOP12*TWOP12)
  300 CONTINUE
      ICARRY = 0
      IF (CARRY .GT. 0.)  ICARRY = 1
      ISDEXT(25) = 1000*J24 + 10*I24 + ICARRY
      RETURN
C                    Entry to initialize from one integer
      ENTRY RCARGO(INSEED)
      JSEED = INSEED
      WRITE(6,'(A,I12)') ' RCARRY INITIALIZED FROM SEED ',INSEED
C      TWOM24 = 1.
         DO 325 I= 1, 24
           TWOM24 = TWOM24 * 0.5
         K = JSEED/53668
         JSEED = 40014*(JSEED-K*53668) -K*12211
         IF (JSEED .LT. 0)  JSEED = JSEED+ICONS
         ISEEDS(I) = MOD(JSEED,ITWO24)
  325    CONTINUE
         DO 350 I= 1,24
         SEEDS(I) = REAL(ISEEDS(I))*TWOM24
  350    CONTINUE
         I24 = 24
         J24 = 10
         CARRY = 0.
         IF (SEEDS(24) .LT. SEEDS(14)) CARRY = TWOM24
      RETURN
      END

      SUBROUTINE RANECU(RVEC,LEN)
C         Random number generator given by L'Ecuyer in
C            Comm. ACM Vol 31, p.742, 1988
C            modified by F. James to return a vector of numbers
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C!!!  Calling sequences for RANECU:                                  ++
C!!!      CALL RANECU (RVEC, LEN)   returns a vector RVEC of LEN     ++
C!!!                   32-bit random floating point numbers between  ++
C!!!                   zero and one.                                 ++
C!!!      CALL RECUIN(I1,I2)    initializes the generator from two   ++
C!!!                   32-bit integers I1 and I2                     ++
C!!!      CALL RECUUT(I1,I2)    outputs the current values of the    ++
C!!!                   two integer seeds, to be used for restarting  ++
C!!! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      DIMENSION RVEC(*)
      SAVE ISEED1,ISEED2
      DATA ISEED1,ISEED2 /12345,67890/
C
      DO 100 I= 1, LEN
      K = ISEED1/53668
      ISEED1 = 40014*(ISEED1 - K*53668) - K*12211
      IF (ISEED1 .LT. 0) ISEED1=ISEED1+2147483563
C
      K = ISEED2/52774
      ISEED2 = 40692*(ISEED2 - K*52774) - K* 3791
      IF (ISEED2 .LT. 0) ISEED2=ISEED2+2147483399
C
      IZ = ISEED1 - ISEED2
      IF (IZ .LT. 1)  IZ = IZ + 2147483562
C
      RVEC(I) = REAL(IZ) * 4.656613E-10
  100 CONTINUE
      RETURN
C
      ENTRY RECUIN(IS1,IS2)
      ISEED1 = IS1
      ISEED2 = IS2
      RETURN
C
      ENTRY RECUUT(IS1,IS2)
      IS1 = ISEED1
      IS2 = ISEED2
      RETURN
      END

      SUBROUTINE VARRAN(DRVEC,LEN)
C     ***************************
C Switchable random number generator
C Translation to double precision
C     ***************************
      COMMON / RANPAR / KEYRND
      DOUBLE PRECISION DRVEC(*)
      DIMENSION RVEC(1000)
      IF(LEN.LT.1.OR.LEN.GT.1000) GOTO 901
   10 CONTINUE
      IF(KEYRND.EQ.1) THEN
         CALL MARRAN(RVEC,LEN)
      ELSEIF(KEYRND.EQ.2) THEN
         CALL RANECU(RVEC,LEN)
      ELSE
         GOTO 902
      ENDIF
C random numbers 0 and 1 not accepted
      DO 30 I=1,LEN
      IF(RVEC(I).LE.0E0.OR.RVEC(I).GE.1E0) THEN
        WRITE(6,*) ' +++++ VARRAN: RVEC=',RVEC(I)
        GOTO 10
      ENDIF
      DRVEC(I)=RVEC(I)
   30 CONTINUE
      RETURN
  901 WRITE(6,*) ' +++++ STOP IN VARRAN: LEN=',LEN
      STOP
  902 WRITE(6,*) ' +++++ STOP IN VARRAN: WRONG KEYRND',KEYRND
      STOP
      END
      SUBROUTINE GAUSJD(FUN,AA,BB,EEPS,RESULT)
C     ****************************************
C Gauss integration by S. Jadach, Oct. 90.
C This is NON-ADAPTIVE (!!!!) UNOPTIMIZED (!!!) integration subprogram.
C     *************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION WG(12),XX(12)
      COMMON / INOUT  / NINP,NOUT,NOUT2
      EXTERNAL FUN
      DATA WG
     $/0.101228536290376D0, 0.222381034453374D0, 0.313706645877887D0,
     $ 0.362683783378362D0, 0.027152459411754D0, 0.062253523938648D0,
     $ 0.095158511682493D0, 0.124628971255534D0, 0.149595988816577D0,
     $ 0.169156519395003D0, 0.182603415044924D0, 0.189450610455069D0/
      DATA XX
     $/0.960289856497536D0, 0.796666477413627D0, 0.525532409916329D0,
     $ 0.183434642495650D0, 0.989400934991650D0, 0.944575023073233D0,
     $ 0.865631202387832D0, 0.755404408355003D0, 0.617876244402644D0,
     $ 0.458016777657227D0, 0.281603550779259D0, 0.095012509837637D0/
      DATA ITERMX / 15/
      EPS=ABS(EEPS)
      A=AA
      B=BB
      NDIVI=1
C iteration over subdivisions terminated by precision requirement
      DO 400 ITER=1,ITERMX
      CALK8  =0D0
      CALK16 =0D0
C sum over DELTA subintegrals
      DO 200 K = 1,NDIVI
      DELTA = (B-A)/NDIVI
      X1    =  A + (K-1)*DELTA
      X2    =  X1+ DELTA
      XMIDLE= 0.5D0*(X2+X1)
      RANGE = 0.5D0*(X2-X1)
      SUM8 =0D0
      SUM16=0D0
C 8- and 12-point   Gauss integration over single DELTA subinterval
      DO 100 I=1,12
      XPLUS= XMIDLE+RANGE*XX(I)
      XMINU= XMIDLE-RANGE*XX(I)
      FPLUS=FUN(XPLUS)
      FMINU=FUN(XMINU)
      IF(I.LE.4) THEN
          SUM8 =SUM8  +(FPLUS+FMINU)*WG(I)/2D0
      ELSE
          SUM16=SUM16 +(FPLUS+FMINU)*WG(I)/2D0
      ENDIF
  100 CONTINUE
      CALK8 = CALK8 + SUM8 *(X2-X1)
      CALK16= CALK16+ SUM16*(X2-X1)
  200 CONTINUE
      ERABS = ABS(CALK16-CALK8)
      ERELA = 0D0
      IF(CALK16.NE.0D0) ERELA= ERABS/ABS(CALK16)
c     write(6,*) 'gausjd: CALK8,CALK16=',ITER,CALK8,CALK16,ERELA
C precision check to terminate integration
      IF(EEPS.GT.0D0) THEN
        IF(ERABS.LT. EPS) GOTO 800
      ELSE
        IF(ERELA.LT. EPS) GOTO 800
      ENDIF
  400 NDIVI=NDIVI*2
      WRITE(NOUT,*) ' +++++ GAUSJD:  REQUIRED PRECISION TO HIGH!'
      WRITE(NOUT,*) ' +++++ GAUSJD:  ITER,ERELA=',ITER,ERELA
  800 RESULT= CALK16
      END


      DOUBLE PRECISION FUNCTION DPGAMM(Z)
C     **********************************
C Double precision Gamma function
      DOUBLE PRECISION Z,Z1,X,X1,X2,X3,D1,D2,D3,S1,S2,S3,PI,C(20),CONST
      DATA C( 1) / 8.3333333333333333333333333332D-02/
      DATA C( 2) /-2.7777777777777777777777777777D-03/
      DATA C( 3) / 7.9365079365079365079365079364D-04/
      DATA C( 4) /-5.9523809523809523809523809523D-04/
      DATA C( 5) / 8.4175084175084175084175084175D-04/
      DATA C( 6) /-1.9175269175269175269175269175D-03/
      DATA C( 7) / 6.4102564102564102564102564102D-03/
      DATA C( 8) /-2.9550653594771241830065359477D-02/
      DATA C( 9) / 1.7964437236883057316493849001D-01/
      DATA C(10) /-1.3924322169059011164274322169D+00/
      DATA C(11) / 1.3402864044168391994478951001D+01/
      DATA C(12) /-1.5684828462600201730636513245D+02/
      DATA C(13) / 2.1931033333333333333333333333D+03/
      DATA C(14) /-3.6108771253724989357173265219D+04/
      DATA C(15) / 6.9147226885131306710839525077D+05/
      DATA C(16) /-1.5238221539407416192283364959D+07/
      DATA C(17) / 3.8290075139141414141414141414D+08/
      DATA C(18) /-1.0882266035784391089015149165D+10/
      DATA C(19) / 3.4732028376500225225225225224D+11/
      DATA C(20) /-1.2369602142269274454251710349D+13/
      DATA PI    / 3.1415926535897932384626433832D+00/
      DATA CONST / 9.1893853320467274178032973641D-01/
      IF(Z.GT.5.75D 1)                                     GOTO  6666
      NN = Z
      IF (Z  -  DBLE(FLOAT(NN)))                 3,1,3
    1 IF (Z    .LE.    0.D 0)                    GOTO 6667
      DPGAMM = 1.D 0
      IF (Z    .LE.    2.D 0)                    RETURN
      Z1 = Z
    2 Z1 = Z1  -  1.D 0
      DPGAMM = DPGAMM * Z1
      IF (Z1  -  2.D 0)                          61,61,2
    3 IF (DABS(Z)    .LT.    1.D-29)             GOTO 60
      IF (Z    .LT.    0.D 0)                    GOTO 4
      X  = Z
      KK = 1
      GOTO 10
    4 X  = 1.D 0  -  Z
      KK = 2
   10 X1 = X
      IF (X    .GT.    19.D 0)                   GOTO 13
      D1 = X
   11 X1 = X1  +  1.D 0
      IF (X1    .GE.    19.D 0)                  GOTO 12
      D1 = D1 * X1
      GOTO 11
   12 S3 = -DLOG(D1)
      GOTO 14
   13 S3 = 0.D 0
   14 D1 = X1 * X1
      S1 = (X1  -  5.D-1) * DLOG(X1)  -  X1  +  CONST
      DO 20                  K=1,20
      S2 = S1  +  C(K)/X1
      IF (DABS(S2  -  S1)    .LT.    1.D-28)     GOTO 21
      X1 = X1 * D1
   20 S1 = S2
   21 S3 = S3  +  S2
      GOTO (50,22),    KK
   22 D2 = DABS(Z  -  NN)
      D1 = D2 * PI
      IF (D1    .LT.    1.D-15)                  GOTO 31
   30 X2 =  DLOG(PI/DSIN(D1))  -  S3
      GOTO 40
   31 X2 = -DLOG(D2)
   40 MM = DABS(Z)
      IF(X2      .GT.      1.74D2)                         GO TO 6666
      DPGAMM = DEXP(X2)
      IF (MM    .NE.    (MM/2) * 2)              RETURN
      DPGAMM = -DPGAMM
      RETURN
   50 IF(S3      .GT.      1.74D2)                         GO TO 6666
      DPGAMM = DEXP(S3)
      RETURN
 6666 PRINT *, 2000
      RETURN
 6667 PRINT *, 2001
      RETURN
   60 DPGAMM = 0.D 0
      IF(DABS(Z)   .LT.   1.D-77)   RETURN
      DPGAMM = 1.D 0/Z
   61 RETURN
 2000 FORMAT (/////, 2X, 32HDPGAMM ..... ARGUMENT TOO LARGE., /////)
 2001 FORMAT (/////, 2X, 32HDPGAMM ..... ARGUMENT IS A POLE., /////)
      END
      SUBROUTINE VESK2W(MODE,FUNSKO,X,Y,WT)
C     *************************************
C=======================================================================
C=======================================================================
C=======================================================================
C===============TWO DIMENSIONAL SAMPLER VESK2W==========================
C=======================================================================
C=======================================================================
C=======================================================================
C                         VESK2W                                       C
C  GENERAL PURPOSE ROUTINE TO GENERATE AN ARBITRARY TWO DIMENSIONAL    C
C  DISTRIBUTION SUPPLIED BY USER IN A FORM OF FUNCTION FUNSKO(X,Y)     C
C                 WRITTEN NOVEMBER 1985                                C
C                    BY S. JADACH                                      C
C                 LAST UPDATE:  07.NOV.1990                            C
C                 version with weighted event....                      C
C======================================================================C
C VESKO2 GENERATES TWO DIMENSIONAL DISTRIBUTION DEFINED BY ARBITRARY
C FUNCTION FUNSKO(X,Y) WHERE X,Y BELONG  TO (0,1) RANGE.
C THE METHOD CONSISTS IN DIVIDING UNIT PLAQUET INTO CELLS USING
C SORT OF 'LIFE-GAME' METHOD IN WHICH THE DIVISION OF A CELLS IS MADE
C (DURING INITIALISATION) ALWAYS FOR THIS CELL WHICH CONTAINS
C A MAXIMUM VALUE OF THE INTEGRAL OVER FUNSKO IN THE CELL.
C RESULTING CELLS CONTAIN (USUALLY UP TO FACTOR TWO) EQUAL INTERGRAL
C VALUE. THE GENERATION CONSISTS IN CHOOSING RANDOMLY  A CELL
C ACCORDING TO ITS CONTENT AND THEN IN GENERATING X,Y WITHIN THE CELL.
C REJECTION METHOD IS APPLIED AT THE END OF THE PROCEDURE IN ORDER TO
C ASSURE THAT X,Y ARE DISTRIBUTED PRECISELY ACCORDING TO FUNSKO(X,Y)
C                    PARAMETERS
C -/ MODE = -1 INITIALISATION, NO (X,Y) GENERATED, CALL VESKO2(-1,D1,D2)
C    HAS TO BE MADE PRIOR  TO GENERATING FIRST (X,Y) PAIR
C -/ MODE =  0 GENERATION OF (X,Y) PAIR BY CALL VESKO2(0,X,Y)
C -/ MODE =  1 CALL VESKO2(1,VALINT,ERRINT) MAY BE DONE AFTER LAST
C    (X,Y) WAS GENERATED IN ORDER TO OBTAIN THE VALUE OF THE INTEGRAL
C    VALINT AND ITS ERROR ERRINT, INTEGRAL IS CALCULATED USING AVERAGE
C    WEIGHTS ENCOUTERED DURING GENERATION PHASE
C -/ X,Y  IF MODE=-1 THE THEY ARE DUMMY
C         IF MODE= 0 THE RESULT OF RANDOM GENERATION ACCORDING TO
C                    FUNCTION FUNSKO, X AND Y BELONG TO (0,1)
C         IF MODE= 1 X= VALUE OF INTEGRAL AND Y=ERROR (RELATIVE)
C                    WT = crude x-section
C ------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      PARAMETER( JLIM1 = 64, JLIM2 = 1000 , NOUT = 6 )
      COMMON / VESW2  / XX(JLIM2,2),DX(JLIM2,2),YY(JLIM2,2,2)
     $  ,YYMX(JLIM2),ZINT(JLIM2),ZSUM,LEV(JLIM2),JMAX
      DOUBLE PRECISION DRVEC(100)
      EXTERNAL FUNSKO
      DATA IWARM/77/
 
      IF(MODE) 100,200,300
C...  INITIALISATION PART, SEE VINSKO FOR MORE COMMENTS
  100 CALL VINSKW(FUNSKO)
      IWARM=0
      WT=0D0
      WTMAX = 1D0
      WTMXX = WTMAX
      NEVOV=0
      SWT=0D0
      SSWT=0D0
      NEVS=0
C(((((((((((((
C     CALL HBOOK1(1, 16H WT-VESKO2     $,75,0.0D0,1.5D0)
C     CALL HMINIM(1,0)
C     CALL HBOOK2(2,16H X-Y VESKO2    $, 64,0,1, 32,0,1,0)
C     CALL HSCALE(2)
C))))))))))))
      RETURN
C...
  200 CONTINUE
C...  GENERATION PART
      IF(IWARM.EQ.77) GO TO 980
cc    IF(WT.GT.WTMAX) THEN
cc      write(6,*) ' vesko2: ev. overweighted, dont worry, wt=',wt
cc      WT=WT-WTMAX
cc      NEVOV=NEVOV+1
cc    ELSE
        CALL VARRAN(DRVEC,3)
        R = DRVEC(1)
        DO 215 J=1,JMAX
        JSTOP=J
  215   IF(ZINT(J).GT.R) GOTO 216
  216   CONTINUE
        XR=XX(JSTOP,1)+DX(JSTOP,1)*DRVEC(2)
        YR=XX(JSTOP,2)+DX(JSTOP,2)*DRVEC(3)
        FN=FUNSKO(XR,YR)
        IF(FN.LT.0.) GOTO 999
        YYMAX=YYMX(JSTOP)
        WT=FN/YYMAX
        WTMXX = MAX(WTMXX,WT)
cc      IF(NEVS.LE.(4*JLIM2).AND.WT.GT.WTMAX) THEN
cc         WTMAX=WT*1.1D0
cc         WRITE(6,*) ' VESKO2: NEVS, new WTMAX= ',NEVS,WTMAX
cc      ENDIF
        NEVS=NEVS+1
        SWT=SWT+WT
        SSWT=SSWT+WT*WT
C((((((((((
C       CALL HFILL(1,WT,0D0,1D0)
C))))))))))
ccc   ENDIF
CCC    CALL VARRAN(DRVEC,1)
ccc    RN=DRVEC(1)
ccc   IF(WTMAX*RN.GT.WT) GOTO 200
      X=XR
      Y=YR
C((((((((((
C     CALL HFILL(2,XR,YR)
C))))))))))
      RETURN
C...
  300 CONTINUE
C THIS IS THE VALUE OF THE INTEGRAL
      CINTEG=ZSUM*SWT/NEVS
C AND ITS ERROR
      ERRINT=SQRT(SSWT/SWT**2-1D0/NEVS)
      X=CINTEG
      Y=ERRINT
      WT=ZSUM
C((((((((((
C     CALL HPRINT(1)
C     CALL HDELET(1)
C     CALL HPRINT(2)
C     CALL HDELET(2)
      PRINT 7000,NEVS,NEVOV,WTMAX,WTMXX
 7000 FORMAT(' VESK2W: NEVS,NEVOV,WTMAX,WTMXX= ',2I7,2F7.3)
C))))))))))
      RETURN
  980 WRITE(NOUT,9002)
 9002 FORMAT(' **** STOP IN VESK2W, LACK OF INITIALISATION   ')
      STOP
  999 WRITE(NOUT,9004)
 9004 FORMAT(' **** STOP IN VESK2W, NEGATIVE VALUE OF FUNSKO ')
      STOP
      END
 
      SUBROUTINE VINSKW(FUNSKO)
C     *************************
C THIS ROUTINE BELONGS TO VESKO2 PACKAGE
C JLIM1 IS THE NUMBER OF CELLS, DIVISION OF THE UNIT PLAQUE INTO CELLS
C IS MADE IN THE FIRST STAGE.    JLIM2 IS THE TOTAL MAXIMUM
C NUMBER OF CELLS, NOTE THAT DIMENSIONS OF
C MATRICES IN /VESKOA/ SHOULD BE AT LEAST JLIM2
C     **********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C ------------------------------------------------------------
      PARAMETER( JLIM1 = 64, JLIM2 = 1000 , NOUT = 6 )
      COMMON / VESW2  / XX(JLIM2,2),DX(JLIM2,2),YY(JLIM2,2,2)
     $  ,YYMX(JLIM2),ZINT(JLIM2),ZSUM,LEV(JLIM2),JMAX
      EXTERNAL FUNSKO
 
C...  INITIALISATION PART, SAMPLING DISTRIBUTION FUNSKO
C...  AND FILLING MATRICES XX,YY,ZINT ETC.
      JMAX=1
      XX(1,1)=0D0
      XX(1,2)=0D0
      DX(1,1)=1D0
      DX(1,2)=1D0
      LEV(1)=1
      SUM=0D0
      DO 150 I=1,2
      DO 150 K=1,2
C... THIS IS NOT ELEGANT BUT SIMPLE
      YY(1,I,K)=FUNSKO(XX(1,1)+(I-1.)*DX(1,1),XX(1,2)+(K-1.)*DX(1,2))
      IF(YY(1,I,K).LT.0.0) GO TO 999
  150 SUM=SUM+YY(1,I,K)
      ZINT(1)=SUM*DX(1,1)*DX(1,2)/4D0
 
      JDIV=1
      DO 200 KK=1,JLIM2-1
      IF(JMAX.LT.JLIM1) THEN
C...    NOTE THAT DIVSKW INCREMENTS JMAX=JMAX+1 IN EVERY CALL
        CALL DIVSKW(JDIV,FUNSKO)
C(((((((((((
c      IF(JMAX.EQ.JLIM1) THEN
c      PRINT 9900,JMAX,(LEV(I),I=1,JMAX)
c 9900 FORMAT(///,' JMAX...  LEV LEV LEV LEV LEV',I10,/(24I5))
c      PRINT 9901,((XX(JD,I),I=1,2),JD=1,JMAX)
c 9901 FORMAT('  XX XX XX XX XX XX XX  ',/(10E12.5))
c      PRINT 9902,((DX(JD,I),I=1,2),JD=1,JMAX)
c 9902 FORMAT('  DX  DX DX DX DX DX ',/(10E12.5))
c      PRINT 9903,(((YY(JD,I,K),I=1,2),K=1,2),JD=1,JMAX)
c 9903 FORMAT('  YY  YY YY YY YY YY ',/(8E15.5))
c      PRINT 9904,(ZINT(I),I=1,JMAX)
c 9904 FORMAT('   ZINT ZINT ZINT ZINT ',/(10E12.5))
c      ENDIF
C))))))))))))
        JDIV=JDIV+2
        IF(JDIV.GT.JMAX) JDIV=1
      ELSE
        JDIV=1
        ZMX=ZINT(1)
        DO 180 J=1,JMAX
        IF(ZMX.LT.ZINT(J)) THEN
          ZMX=ZINT(J)
          JDIV=J
        ENDIF
  180   CONTINUE
        CALL DIVSKW(JDIV,FUNSKO)
      ENDIF
  200 CONTINUE
 
C(((((((((((
c      JPRN=64
c      PRINT 9910,JMAX,(LEV(I),I=1,JMAX)
c 9910 FORMAT(/,' JMAX...  LEV LEV LEV LEV LEV',I10,/(24I5))
c      IF(JMAX.LE.JPRN) PRINT 9911,((XX(JD,I),I=1,2),JD=1,JMAX)
c 9911 FORMAT('  XX XX XX XX XX XX XX  ',/(10E12.5))
c      IF(JMAX.LE.JPRN) PRINT 9912,((DX(JD,I),I=1,2),JD=1,JMAX)
c 9912 FORMAT('  DX  DX DX DX DX DX ',/(10E12.5))
c      IF(JMAX.LE.JPRN) PRINT 9913,(((YY(JD,I,K),I=1,2),K=1,2),JD=1,JMAX)
c 9913 FORMAT('  YY  YY YY YY YY YY ',/(8E15.5))
c      IF(JMAX.LE.JPRN) PRINT 9914,(ZINT(I),I=1,JMAX)
c 9914 FORMAT('   ZINT ZINT ZINT ZINT ',/(10E12.5))
C     DO 902 J=1,JMAX
C     Z=1D0*J-.5D0
C 902 CALL HFILL(202,Z,ZINT(J))
C))))))))))))
C...  FINAL ADMINISTRATION, NORMALIZING ZINT ETC.
      ZSUM1=0D0
      ZSUM =0D0
      DO 260 J=1,JMAX
      ZSUM1=ZSUM1+ZINT(J)
      YMAX= 0D0
      DO 250 I=1,2
      DO 250 K=1,2
  250 YMAX= MAX(YMAX,YY(J,I,K))
      YYMX(J)=YMAX
      ZINT(J)=YMAX*DX(J,1)*DX(J,2)
  260 ZSUM=ZSUM+ZINT(J)
C((((((((
      ZR=ZSUM1/ZSUM
      PRINT 7000,ZR
 7000 FORMAT(' /////// ZSUM1/ZSUM= ',F20.8)
C)))))))))
      SUM=0D0
      DO 240 J=1,JMAX
      SUM=SUM+ZINT(J)
  240 ZINT(J)=SUM/ZSUM
C(((((((((((
c     JPRN=64
c     PRINT 9932,JMAX
c9932 FORMAT(/'=====JMAX ZINT ZINT ZINT  ',I10)
c     IF(JMAX.LE.JPRN) PRINT 9935,(ZINT(I),I=1,JMAX)
c9935            FORMAT(10E12.5)
C     DO 901 J=2,JMAX
C 901 CALL HFILL(201,(ZINT(J)-ZINT(J-1))*JMAX)
C     CALL HFILL(201,ZINT(1)*JMAX)
C))))))))))))
      RETURN
  999 WRITE(NOUT,9000)
 9000 FORMAT(' **** STOP IN VINSKW, NEGATIVE VALUE OF FUNSKO ')
      STOP
      END
 
      SUBROUTINE DIVSKW(JD,FUNSKO)
C     ****************************
C THIS ROUTINE BELONGS TO VESKO2 PACKAGE
C IT SUBDIVIDES ONE CELL (NO. JD) INTO TWO EQUAL SIZE CELLS
C     **********************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C ------------------------------------------------------------
      PARAMETER( JLIM1 = 64, JLIM2 = 1000 , NOUT = 6 )
      COMMON / VESW2  / XX(JLIM2,2),DX(JLIM2,2),YY(JLIM2,2,2)
     $  ,YYMX(JLIM2),ZINT(JLIM2),ZSUM,LEV(JLIM2),JMAX
      EXTERNAL FUNSKO
 
C...  MOOVE TO MAKE A HOLE FOR A NEW ENTRY (ONE ADDITIONAL CELL)
      DO 100 J=JMAX,JD,-1
      ZINT(J+1)=ZINT(J)
      LEV(J+1)=LEV(J)
      DO 100 I=1,2
      XX(J+1,I)  =XX(J,I)
      DX(J+1,I)  =DX(J,I)
      DO 100 K=1,2
  100 YY(J+1,I,K)  =YY(J,I,K)
C...  CREATE TWO NEW CELLS AND STORE THEM
      LL= MOD(LEV(JD),2)+1
      DX(JD,LL)=DX(JD,LL)/2D0
      DX(JD+1,LL)=DX(JD+1,LL)/2D0
      XX(JD+1,LL)=XX(JD,LL)+DX(JD,LL)
      IF(LL.EQ.1) THEN
        DO 150 I=1,2
C... THIS IS NOT ELEGANT, PROBABLY COULD BE DONE BETTER
        YY(JD,2,I)=FUNSKO(XX(JD,1)+DX(JD,1),XX(JD,2)+(I-1.)*DX(JD,2))
  150   YY(JD+1,1,I)=YY(JD,2,I)
      ELSE
        DO 152 I=1,2
        YY(JD,I,2)=FUNSKO(XX(JD,1)+(I-1.)*DX(JD,1),XX(JD,2)+DX(JD,2))
  152   YY(JD+1,I,1)=YY(JD,I,2)
      ENDIF
C...  ESTIMATE THE INTEGRALS OVER NEW CELLS RESULTING FROM DIVISION
      DO 220 JDV=JD,JD+1
      LEV(JDV)=LEV(JDV)+1
      SUM=0D0
      DO 210 I=1,2
      DO 210 K=1,2
      IF(YY(JDV,I,K).LT.0.D0) GO TO 999
  210 SUM=SUM+YY(JDV,I,K)
  220 ZINT(JDV) =SUM*DX(JDV,1)*DX(JDV,2)/4D0
      JMAX=JMAX+1
      RETURN
  999 WRITE(NOUT,9000)
 9000 FORMAT(' **** STOP IN DIVSKW, NEGATIVE VALUE OF FUNSKO ')
      STOP
      END
 



      SUBROUTINE WMONIT(MODE,ID,WT,WTMAX,RN)
C     **************************************
C last correction 19 sept. 89
C Utility program for monitoring M.C. rejection weights.
C ID is weight idendifier, maximum IDMX (defined below).
C WT IS WEIGHT, WTMAX IS MAXIMUM WEIGHT AND RN IS RANDOM NUMBER.
C IF(MODE.EQ.-1) THEN
C          INITALIZATION IF ENTRY ID, OTHER ARGUMENTS ARE IGNORED
C ELSEIF(MODE.EQ.0) THEN
C          SUMMING UP WEIGHTS ETC. FOR A GIVEN EVENT FOR ENTRY ID
C        - WT IS CURRENT WEIGHT.
C        - WTMAX IS MAXIMUM WEIGHT USED FOR COUTING OVERWEIGHTED
C          EVENTS WITH WT>WTMAX.
C        - RN IS RANDOM NUMBER USED IN REJECTION, IT IS USED TO
C          COUNT NO. OF ACCEPTED (RN<WT/WTMAX) AND REJECTED
C          (WT>WT/WTMAX) EVENTS,
C          IF RO REJECTION THEN PUT RN=0D0.
C ELSEIF(MODE.EQ.1) THEN
C          IN THIS MODE WMONIT REPPORTS ON ACCUMULATED STATISTICS
C          AND THE INFORMATION IS STORED IN COMMON /CMONIT/
C        - AVERWT= AVERAGE WEIGHT WT COUNTING ALL EVENT
C        - ERRELA= RELATIVE ERROR OF AVERWT
C        - NEVTOT= TOTAL NIMBER OF ACCOUNTED EVENTS
C        - NEVACC= NO. OF ACCEPTED EVENTS (RN<WT\WTMAX)
C        - NEVNEG= NO. OF EVENTS WITH NEGATIVE WEIGHT (WT<0)
C        - NEVZER= NO. OF EVENTS WITH ZERO WEIGHT (WT.EQ.0D0)
C        - NEVOVE= NO. OF OVERWEGHTED EVENTS (WT>WTMAX)
C          AND IF YOU DO NOT WANT TO USE CMONIT THEN THE VALUE
C          The value of AVERWT is assigned to WT,
C          the value of ERRELA is assigned to WTMAX and
C          the value of WTMAX  is assigned to RN in this mode.
C ELSEIF(MODEE.EQ.2) THEN
C          ALL INFORMATION DEFINED FOR ENTRY ID DEFINED ABOVE
C          FOR MODE=2 IS JUST PRINTED OF UNIT NOUT
C ENDIF
C NOTE THAT OUTPUT REPPORT (MODE=1,2) IS DONE DYNAMICALLY JUST FOR A
C GIVEN ENTRY ID ONLY AND IT MAY BE REPEATED MANY TIMES FOR ONE ID AND
C FOR VARIOUS ID'S AS WELL.
C     ************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER(IDMX=100)
      COMMON / CMONIT/ AVERWT,ERRELA,NEVTOT,NEVACC,NEVNEG,NEVOVE,NEVZER
      COMMON / INOUT  / NINP,NOUT,NOUT2
      INTEGER NTOT(IDMX),NACC(IDMX),NNEG(IDMX),NOVE(IDMX),NZER(IDMX)
      DIMENSION SWT(IDMX),SSWT(IDMX),WWMX(IDMX)
      DATA NTOT /IDMX* -1/  SWT /IDMX*   0D0/
      DATA SSWT /IDMX*0D0/ WWMX /IDMX*-1D-20/
C
      IF(ID.LE.0.OR.ID.GT.IDMX) THEN
           WRITE(NOUT,*) ' =====WMONIT: WRONG ID',ID
           STOP
      ENDIF
      IF(MODE.EQ.-1) THEN
           NTOT(ID)=0
           NACC(ID)=0
           NNEG(ID)=0
           NZER(ID)=0
           NOVE(ID)=0
           SWT(ID)   =0D0
           SSWT(ID)  =0D0
           WWMX(ID)  = -1D-20
      ELSEIF(MODE.EQ.0) THEN
           IF(NTOT(ID).LT.0) THEN
              WRITE(NOUT,*) ' ==== WARNING FROM WMONIT: '
              WRITE(NOUT,*) ' LACK OF INITIALIZATION, ID=',ID
           ENDIF
           NTOT(ID)=NTOT(ID)+1
           SWT(ID)=SWT(ID)+WT
           SSWT(ID)=SSWT(ID)+WT**2
           WWMX(ID)= MAX(WWMX(ID),WT)
           IF(WT.EQ.0D0)   NZER(ID)=NZER(ID)+1
           IF(WT.LT.0D0)   NNEG(ID)=NNEG(ID)+1
           IF(WT.GT.WTMAX)      NOVE(ID)=NOVE(ID)+1
           IF(RN*WTMAX.LE.WT)   NACC(ID)=NACC(ID)+1
      ELSEIF(MODE.EQ.1) THEN
           IF(NTOT(ID).LT.0) THEN
              WRITE(NOUT,*) ' ==== WARNING FROM WMONIT: '
              WRITE(NOUT,*) ' LACK OF INITIALIZATION, ID=',ID
           ENDIF
           IF(NTOT(ID).LE.0.OR.SWT(ID).EQ.0D0)  THEN
              AVERWT=0D0
              ERRELA=0D0
           ELSE
              AVERWT=SWT(ID)/FLOAT(NTOT(ID))
              ERRELA=SQRT(ABS(SSWT(ID)/SWT(ID)**2-1D0/FLOAT(NTOT(ID))))
           ENDIF
           NEVTOT=NTOT(ID)
           NEVACC=NACC(ID)
           NEVNEG=NNEG(ID)
           NEVZER=NZER(ID)
           NEVOVE=NOVE(ID)
           WT=AVERWT
           WTMAX=ERRELA
           RN    =WWMX(ID)
      ELSEIF(MODE.EQ.2) THEN
           IF(NTOT(ID).LE.0.OR.SWT(ID).EQ.0D0)  THEN
              AVERWT=0D0
              ERRELA=0D0
           ELSE
              AVERWT=SWT(ID)/FLOAT(NTOT(ID))
              ERRELA=SQRT(ABS(SSWT(ID)/SWT(ID)**2-1D0/FLOAT(NTOT(ID))))
              WWMAX=WWMX(ID)
           ENDIF
           WRITE(NOUT,1003) ID, AVERWT, ERRELA, WWMAX
           WRITE(NOUT,1004) NTOT(ID),NACC(ID),NNEG(ID),NOVE(ID),NZER(ID)
           WT=AVERWT
           WTMAX=ERRELA
           RN    =WWMX(ID)
      ELSE
           WRITE(NOUT,*) ' =====WMONIT: WRONG MODE',MODE
           STOP
      ENDIF
 1003 FORMAT(
     $  ' =======================WMONIT========================'
     $/,'   ID           AVERWT         ERRELA            WWMAX'
     $/,    I5,           E17.7,         F15.9,           E17.7)
 1004 FORMAT(
     $  ' -----------------------------------------------------------'
     $/,'      NEVTOT      NEVACC      NEVNEG      NEVOVE      NEVZER'
     $/,   5I12)
      END

      SUBROUTINE WMONI2(MODE,ID,WT,WTMAX,RN)
C     **************************************
C -------------- SECOND COPY OF WMONIT ----------------
C last correction 19 sept. 89
C Utility program for monitoring M.C. rejection weights.
C ID is weight idendifier, maximum IDMX (defined below).
C WT IS WEIGHT, WTMAX IS MAXIMUM WEIGHT AND RN IS RANDOM NUMBER.
C IF(MODE.EQ.-1) THEN
C          INITALIZATION IF ENTRY ID, OTHER ARGUMENTS ARE IGNORED
C ELSEIF(MODE.EQ.0) THEN
C          SUMMING UP WEIGHTS ETC. FOR A GIVEN EVENT FOR ENTRY ID
C        - WT IS CURRENT WEIGHT.
C        - WTMAX IS MAXIMUM WEIGHT USED FOR COUTING OVERWEIGHTED
C          EVENTS WITH WT>WTMAX.
C        - RN IS RANDOM NUMBER USED IN REJECTION, IT IS USED TO
C          COUNT NO. OF ACCEPTED (RN<WT/WTMAX) AND REJECTED
C          (WT>WT/WTMAX) EVENTS,
C          IF RO REJECTION THEN PUT RN=0D0.
C ELSEIF(MODE.EQ.1) THEN
C          IN THIS MODE WMONIT REPPORTS ON ACCUMULATED STATISTICS
C          AND THE INFORMATION IS STORED IN COMMON /CMONIT/
C        - AVERWT= AVERAGE WEIGHT WT COUNTING ALL EVENT
C        - ERRELA= RELATIVE ERROR OF AVERWT
C        - NEVTOT= TOTAL NIMBER OF ACCOUNTED EVENTS
C        - NEVACC= NO. OF ACCEPTED EVENTS (RN<WT\WTMAX)
C        - NEVNEG= NO. OF EVENTS WITH NEGATIVE WEIGHT (WT<0)
C        - NEVZER= NO. OF EVENTS WITH ZERO WEIGHT (WT.EQ.0D0)
C        - NEVOVE= NO. OF OVERWEGHTED EVENTS (WT>WTMAX)
C          AND IF YOU DO NOT WANT TO USE CMONIT THEN THE VALUE
C          The value of AVERWT is assigned to WT,
C          the value of ERRELA is assigned to WTMAX and
C          the value of WTMAX  is assigned to RN in this mode.
C ELSEIF(MODEE.EQ.2) THEN
C          ALL INFORMATION DEFINED FOR ENTRY ID DEFINED ABOVE
C          FOR MODE=2 IS JUST PRINTED OF UNIT NOUT
C ENDIF
C NOTE THAT OUTPUT REPPORT (MODE=1,2) IS DONE DYNAMICALLY JUST FOR A
C GIVEN ENTRY ID ONLY AND IT MAY BE REPEATED MANY TIMES FOR ONE ID AND
C FOR VARIOUS ID'S AS WELL.
C     ************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      PARAMETER(IDMX=100)
      COMMON / CMONI2/ AVERWT,ERRELA,NEVTOT,NEVACC,NEVNEG,NEVOVE,NEVZER
      COMMON / INOUT  / NINP,NOUT,NOUT2
      INTEGER NTOT(IDMX),NACC(IDMX),NNEG(IDMX),NOVE(IDMX),NZER(IDMX)
      DIMENSION SWT(IDMX),SSWT(IDMX),WWMX(IDMX)
      DATA NTOT /IDMX* -1/  SWT /IDMX*   0D0/
      DATA SSWT /IDMX*0D0/ WWMX /IDMX*-1D-20/
C
      IF(ID.LE.0.OR.ID.GT.IDMX) THEN
           WRITE(NOUT,*) ' =====WMONI2: WRONG ID',ID
           STOP
      ENDIF
      IF(MODE.EQ.-1) THEN
           NTOT(ID)=0
           NACC(ID)=0
           NNEG(ID)=0
           NZER(ID)=0
           NOVE(ID)=0
           SWT(ID)   =0D0
           SSWT(ID)  =0D0
           WWMX(ID)  = -1D-20
      ELSEIF(MODE.EQ.0) THEN
           IF(NTOT(ID).LT.0) THEN
              WRITE(NOUT,*) ' ==== WARNING FROM WMONIT: '
              WRITE(NOUT,*) ' LACK OF INITIALIZATION, ID=',ID
           ENDIF
           NTOT(ID)=NTOT(ID)+1
           SWT(ID)=SWT(ID)+WT
           SSWT(ID)=SSWT(ID)+WT**2
           WWMX(ID)= MAX(WWMX(ID),WT)
           IF(WT.EQ.0D0)   NZER(ID)=NZER(ID)+1
           IF(WT.LT.0D0)   NNEG(ID)=NNEG(ID)+1
           IF(WT.GT.WTMAX)      NOVE(ID)=NOVE(ID)+1
           IF(RN*WTMAX.LE.WT)   NACC(ID)=NACC(ID)+1
      ELSEIF(MODE.EQ.1) THEN
           IF(NTOT(ID).LT.0) THEN
              WRITE(NOUT,*) ' ==== WARNING FROM WMONI2: '
              WRITE(NOUT,*) ' LACK OF INITIALIZATION, ID=',ID
           ENDIF
           IF(NTOT(ID).LE.0.OR.SWT(ID).EQ.0D0)  THEN
              AVERWT=0D0
              ERRELA=0D0
           ELSE
              AVERWT=SWT(ID)/FLOAT(NTOT(ID))
              ERRELA=SQRT(ABS(SSWT(ID)/SWT(ID)**2-1D0/FLOAT(NTOT(ID))))
           ENDIF
           NEVTOT=NTOT(ID)
           NEVACC=NACC(ID)
           NEVNEG=NNEG(ID)
           NEVZER=NZER(ID)
           NEVOVE=NOVE(ID)
           WT=AVERWT
           WTMAX=ERRELA
           RN    =WWMX(ID)
      ELSEIF(MODE.EQ.2) THEN
           IF(NTOT(ID).LE.0.OR.SWT(ID).EQ.0D0)  THEN
              AVERWT=0D0
              ERRELA=0D0
           ELSE
              AVERWT=SWT(ID)/FLOAT(NTOT(ID))
              ERRELA=SQRT(ABS(SSWT(ID)/SWT(ID)**2-1D0/FLOAT(NTOT(ID))))
              WWMAX=WWMX(ID)
           ENDIF
           WRITE(NOUT,1003) ID, AVERWT, ERRELA, WWMAX
           WRITE(NOUT,1004) NTOT(ID),NACC(ID),NNEG(ID),NOVE(ID),NZER(ID)
           WT=AVERWT
           WTMAX=ERRELA
           RN    =WWMX(ID)
      ELSE
           WRITE(NOUT,*) ' =====WMONI2: WRONG MODE',MODE
           STOP
      ENDIF
 1003 FORMAT(
     $  ' =======================WMONI2========================'
     $/,'   ID           AVERWT         ERRELA            WWMAX'
     $/,    I5,           E17.7,         F15.9,           E17.7)
 1004 FORMAT(
     $  ' -----------------------------------------------------------'
     $/,'      NEVTOT      NEVACC      NEVNEG      NEVOVE      NEVZER'
     $/,   5I12)
      END
      DOUBLE PRECISION FUNCTION DILOG(X)
C-------------------------------------------- REMARKS ---------------
C DILOGARITHM FUNCTION: DILOG(X)=INT( -LN(1-Z)/Z ) , 0 < Z < X .
C THIS IS THE CERNLIB VERSION.
C--------------------------------------------------------------------
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      Z=-1.644934066848226D0
      IF(X .LT.-1.D0) GO TO 1
      IF(X .LE. 0.5D0) GO TO 2
      IF(X .EQ. 1.D0) GO TO 3
      IF(X .LE. 2.D0) GO TO 4
      Z=3.289868133696453D0
    1 T=1.D0/X
      S=-0.5D0
      Z=Z-0.5D0*DLOG(DABS(X))**2
      GO TO 5
    2 T=X
      S=0.5D0
      Z=0.D0
      GO TO 5
    3 DILOG=1.644934066848226D0
      RETURN
    4 T=1.D0-X
      S=-0.5D0
      Z=1.644934066848226D0-DLOG(X)*DLOG(DABS(T))
    5 Y=2.666666666666667D0*T+0.666666666666667D0
      B=      0.000000000000001D0
      A=Y*B  +0.000000000000004D0
      B=Y*A-B+0.000000000000011D0
      A=Y*B-A+0.000000000000037D0
      B=Y*A-B+0.000000000000121D0
      A=Y*B-A+0.000000000000398D0
      B=Y*A-B+0.000000000001312D0
      A=Y*B-A+0.000000000004342D0
      B=Y*A-B+0.000000000014437D0
      A=Y*B-A+0.000000000048274D0
      B=Y*A-B+0.000000000162421D0
      A=Y*B-A+0.000000000550291D0
      B=Y*A-B+0.000000001879117D0
      A=Y*B-A+0.000000006474338D0
      B=Y*A-B+0.000000022536705D0
      A=Y*B-A+0.000000079387055D0
      B=Y*A-B+0.000000283575385D0
      A=Y*B-A+0.000001029904264D0
      B=Y*A-B+0.000003816329463D0
      A=Y*B-A+0.000014496300557D0
      B=Y*A-B+0.000056817822718D0
      A=Y*B-A+0.000232002196094D0
      B=Y*A-B+0.001001627496164D0
      A=Y*B-A+0.004686361959447D0
      B=Y*A-B+0.024879322924228D0
      A=Y*B-A+0.166073032927855D0
      A=Y*A-B+1.935064300869969D0
      DILOG=S*T*(A-B)+Z
      END


