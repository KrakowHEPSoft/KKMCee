      SUBROUTINE TauMake(Mode)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  Basic routine of Tauola interface. Mode=-1,0,1 denote respectively             //
*//  initialization, generation and final printouts of Tauola                       //
*//  beam polarizations is provided by  CALL  GPS_SpinBeam(1,e1,e2)                 //
*//  appropriate  rotations sign arrangements are performed                         //
*//  note sign difference withy respect to fs and rotation of e1 around 2-nd axis   //
*//  the two operations are not done in an explicit way                             //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      INTEGER   Mode
      REAL*8    HH1(4),HH2(4),p3(4),p4(4)
* switches for tauola;
      COMMON / JAKI   /  JAK1,JAK2,JAKP,JAKM,KTOM
      COMMON / IDFC   /  IDFF 
* I/O units  numbers
      COMMON / INOUT  /  INUT,IOUT
* lund type identifier for A1
      COMMON / IDPART /  IA1
      COMMON / TAURAD /  XK0DEC,ITDKRC
      REAL*8             XK0DEC
      COMMON / TESTA1 /  KEYA1
* special switch for tests of dGamma/dQ**2 in a1 decay
* KEYA1=1 constant width of a1 and rho
* KEYA1=2 free choice of rho propagator (defined in function FPIK)
*         and free choice of a1 mass and width. function g(Q**2)
*         (see formula 3.48 in Comp. Phys. Comm. 64 (1991) 275)
*         hard coded both in Monte Carlo and in testing distribution.
* KEYA1=3 function g(Q**2) hardcoded in the Monte Carlo
*         (it is timy to calculate!), but appropriately adjusted in
*         testing distribution.

*     **********************
      IF (Mode .EQ. -1) THEN
*     **********************
         IOUT=6
         NINP=INUT
         NOUT=IOUT
         CALL GPS_Initialize
         xk0dec=0.001
         itdkrc=1
         JAK1=3
         JAK2=3
* Lund identifier (for tau+) -15
         IDFF= 15
* kto=1 denotes tau defined by idff (i.e. tau+)
* kto=2 denotes the opposite        (i.e. tau-)
         KTO=2
         WRITE(IOUT,7004) KEYA1,IDFF,ITDKRC,xk0dec
* Initialisation of tau decay package tauola
         CALL INIMAS
         CALL INITDK
         CALL INIPHY(0.1D0)
         CALL DEKAY(-1,HH1)
         IF(ITDKRC .EQ. 1)   CALL PHOINI
*     **************************
      ELSEIF ( Mode .EQ. 0) THEN
*     **************************
         CALL MBR_GetKF(KFf)
         IF (abs(kff).ne.15) return
         idff=kff
         CALL DEKAY(1,HH1)
         CALL DEKAY(2,HH2)
         CALL TauSpinMake(HH1,HH2)
*        -------------------------
         CALL KarFin_GetFermions( p3,p4)
         CALL GPS_tralorPrepare(p3,1)
         CALL GPS_tralorPrepare(p4,2)
         CALL DEKAY(1+10,HH1)
         CALL DEKAY(2+10,HH2)
         IF(ITDKRC.EQ.1) CALL PHOTOS_KK(3)
         IF(ITDKRC.EQ.1) CALL PHOTOS_KK(4)
         CALL HepEvt_LuHepc(2) 
*     ***********************
      ELSEIF (Mode.eq.1) THEN
*     ***********************
         CALL DEKAY(100,HH1)
      ELSE
*     ****
         WRITE(*,*) 'stop in  TauMake wrong Mode=',Mode
         STOP
      ENDIF
 7004 FORMAT(//4(/1X,15(5H=====))
     $ /,'  ',     19X,'             ',9X,1H ,
     $ /,'  ',     19X,'      TauMake: TAUOLA INTERFACE        ',9X,1H ,
     $ /,'  ',     19X,'         OF THE KORAL-B TYPE           ',9X,1H ,
     $ /,'  ',     19X,'             20.July.1998              ',9X,1H ,
     $ /,'  ',     19X,'             ',9X,1H ,
     $  2(/,1X,15(5H=====)),
     $ /,5X ,'JAK   =',I7  ,'  TYPE OF CURRENT in A1 decay     ',9X,1H ,
     $ /,5X ,'IDFF  =',I7  ,'  LUND IDENTIFIER FOR FIRST TAU   ',9X,1H ,
     $ /,5X ,'ITDKRC=',I7  ,'  Rad. corr. switch for lept decay',9X,1H ,
     $ /,5X ,'xk0dec=',F7.4,'  soft/hard separation for r.c.   ',9X,1H ,
     $  2(/,1X,15(5H=====))/)
      END
 

      SUBROUTINE TauSpinMake(HH1,HH2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Generation of actual orientation of tau decay products with respect           //
*//   to frames implicitely defined by  production amplitudes.                      //
*//   Warning: average of the weight wt=tauspinweight(tensor) over the 4 pi angles  //
*//   in tau+ tau- restframes must be exactly 1/4 for all combinations of  other    //
*//   kinematical variables.                                                        //
*//   Output is hiddeen in  thet1,phi1,thet2,phi2 internal variables                //
*//   of subroutine RandomRotate.                                                   //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT REAL*8 (a-h,o-z)
      DIMENSION hh1(4),hh2(4),ha1(4),ha2(4),hb1(4),hb2(4),hx1(3),hx2(3)
      COMPLEX*16 tensor(2,2,2,2,2,2,2,2)
      REAL*4 rrr(10)
      DATA pi    / 3.1415926535897932384626433832d+00/

      CALL GPS_tensor(tensor)
c{{{{{
* setting polarization in y-z plane
c      phi1=acos(hh1(2)/sqrt(hh1(1)**2+hh1(2)**2))
c      phi2=acos(hh2(2)/sqrt(hh2(1)**2+hh2(2)**2))
c      IF (hh1(1).lt.0d0) phi1=2*pi-phi1
c      IF (hh2(1).lt.0d0) phi2=2*pi-phi2
c      CALL rotod3(phi1,hh1,ha1)
c      CALL rotod3(phi2,hh2,ha2)
c
* setting polarization in +z direction
c      thet1=acos(ha1(3)/sqrt(ha1(2)**2+ha1(3)**2))
c      thet2=acos(ha2(3)/sqrt(ha2(2)**2+ha2(3)**2))
c      IF (ha1(2).lt.0d0) write(*,*) 'ha1(2) lt 0 !!!'
c      IF (ha2(2).lt.0d0) write(*,*) 'ha2(2) lt 0 !!!'
c      CALL rotod1(thet1,ha1,hb1)
c      CALL rotod1(thet2,ha2,hb2)
c}}}}}
 10   CONTINUE
      CALL PseuMar_MakeVec(rrr,1)
c{{{{{
c      CALL RandomRotate(1,hb1,hx1,thet1,phi1,thet2,phi2)
c      CALL RandomRotate(2,hb2,hx2,thet1,phi1,thet2,phi2)
c}}}}}
      CALL RandomRotate(1,hh1,hx1,thet1,phi1,thet2,phi2)
      CALL RandomRotate(2,hh2,hx2,thet1,phi1,thet2,phi2)
      CALL GPS_SpinStore(0,HX1,HX2)
* wyliczyc wage z zadanych amplitud.
      wt=tauspinweight(tensor)
      IF (wt .LT. rrr(1)) GOTO 10

      END

      SUBROUTINE RandomRotate(Mode,hh,hy,thet1,phi1,thet2,phi2)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Generation of random two independent random rotations                         //
*//   of 4-vector hh into 3-vector hy is performed for Mode=1 or 2                  //
*//   For Mode=0 stored rotation angles can be passed out e.g. to tralor.           //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT real*8 (a-h,o-z)
      DIMENSION hh(4),hx(4),hy(3),qvec(4)
      REAL*4 rrr(10)
      DATA pi    / 3.1415926535897932384626433832d+00/
      SAVE thet1x,phi1x,thet2x,phi2x
      SAVE thet1a,phi1a,thet2a,phi2a
      
      IF (Mode.eq.-1) then
         thet1=thet1a
         phi1 =phi1a
         thet2=thet1x
         phi2 =phi1x
      ELSEIF (Mode.eq.-2) then
         thet1=thet2a
         phi1 =phi2a
         thet2=thet2x
         phi2 =phi2x
      ELSE
         CALL PseuMar_MakeVec(rrr,2)
         th=acos(2d0*RRR(1)-1D0)
         ph=2d0*pi*RRR(2)
         CALL rotod1(th,HH,qvec)
         CALL rotod3(ph,qvec,HX)
         DO k=1,3
            HY(k)=HX(k)
         ENDDO
         IF (Mode.eq.1) then
            thet1x=th
            phi1x =ph 
            thet1a=thet1
            phi1a =phi1
         ELSEIF (Mode.eq.2) then
            thet2x=th
            phi2x =ph
            thet2a=thet2
            phi2a =phi2
         ELSE
            write(*,*) 'stop in RandomRotate wrong Mode=',Mode
         ENDIF
      ENDIF  
      END

      FUNCTION tauspinweight(tensor)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Calculation of the spin weight for tau spin effects from                      //
*//   production density matrix tensor(2,2,2,2,2,2,2,2) initial DensityMe1(2,2),    //
*//   DensityMe2(2,2) and final state DensityMf1(2,2), DensityMf2(2,2)              //
*//   density matrices                                                              //
*//   WARNING: it should not be used for genuine beam spin effects implementation   //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT real*8 (a-h,o-z)
      REAL*8 numerator
      COMPLEX*16 tensor(2,2,2,2,2,2,2,2),ccsum
      COMPLEX*16 DensityMe1(2,2), DensityMe2(2,2), DensityMf1(2,2), DensityMf2(2,2)

      CALL GPS_SpinGiveBeam(1,DensityMe1)
      CALL GPS_SpinGiveBeam(2,DensityMe2)     
      CALL GPS_SpinGive(1,DensityMf1)
      CALL GPS_SpinGive(2,DensityMf2)

      ccSum=0d0
      DO j1=1,2
         DO i1=1,2
            DO j2=1,2
               DO i2=1,2
                  DO j3=1,2
                     DO i3=1,2
                        DO j4=1,2
                           DO i4=1,2
                              ccSum=ccSum+ tensor(i1,j1,i2,j2,i3,j3,i4,j4)
     $                                            *DensityMe1(j1,i1)
     $                                            *DensityMe2(j2,i2)
     $                                            *DensityMf1(j3,i3)
     $                                            *DensityMf2(j4,i4)
                           ENDDO
                        ENDDO
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      numerator=ccsum

      ccSum=0d0
      DO j1=1,2
         DO i1=1,2
            DO j2=1,2
               DO i2=1,2
                  DO i3=1,2
                     DO i4=1,2
                        ccSum=ccSum+ tensor(i1,j1,i2,j2,i3,i3,i4,i4)
     $                                            *DensityMe1(j1,i1)
     $                                            *DensityMe2(j2,i2)
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      denominator=ccsum
      tauspinweight=numerator/denominator/4d0
* Next two lines are for tests they assure  constant series independentlu
* of spin implementation actually used.
*      write(*,*) 'spin wt=',tauspinweight
*      tauspinweight=0.25d0
      END

      FUNCTION beamspinweight(tensor)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Calculation of the spin weight for beamspin effects from                      //
*//   production density matrix tensor(2,2,2,2,2,2,2,2) initial DensityMe1(2,2),    //
*//   DensityMe2(2,2)                                                               //
*//   WARNING: it should  be used for genuine beam spin effects implementation      //
*//                                                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      IMPLICIT real*8 (a-h,o-z)
      REAL*8 numerator
      COMPLEX*16 tensor(2,2,2,2,2,2,2,2),ccsum
      COMPLEX*16 DensityMe1(2,2), DensityMe2(2,2)
      CALL GPS_SpinGiveBeam(1,DensityMe1)
      CALL GPS_SpinGiveBeam(2,DensityMe2)     

      ccSum=0d0
      DO j1=1,2
         DO i1=1,2
            DO j2=1,2
               DO i2=1,2
                  DO i3=1,2
                     DO i4=1,2
                        ccSum=ccSum+ tensor(i1,j1,i2,j2,i3,i3,i4,i4)
     $                                            *DensityMe1(j1,i1)
     $                                            *DensityMe2(j2,i2)
                     ENDDO
                  ENDDO
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      numerator=ccsum

      ccSum=0d0
      DO i1=1,2
         DO i2=1,2
            DO i3=1,2
               DO i4=1,2
                  ccSum=ccSum+ tensor(i1,i1,i2,i2,i3,i3,i4,i4)
               ENDDO
            ENDDO
         ENDDO
      ENDDO
      denominator=ccsum
      beamspinweight=numerator/denominator/4d0
* Next two lines are for tests they assure  constant series independentlu
* of spin implementation actually used.
*      write(*,*) 'spin wt=',beamspinweight
      beamspinweight=0.25d0
      END


      SUBROUTINE CHOICE(MNUM,RR,ICHAN,PROB1,PROB2,PROB3,
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//   Standard Tauola interface/initialization routines of functionality exactly    //
*//   as in Tauola CPC                                                              //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
     $            AMRX,GAMRX,AMRA,GAMRA,AMRB,GAMRB)
      COMMON / PARMAS / AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      REAL*4            AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      AMROP=1.1
      GAMROP=0.36
      AMOM=.782
      GAMOM=0.0084
*     XXXXA CORRESPOND TO S2 CHANNEL !
      IF(MNUM.EQ.0) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =AMA1
         GAMRX=GAMA1
         AMRA =AMRO
         GAMRA=GAMRO
         AMRB =AMRO
         GAMRB=GAMRO
      ELSEIF(MNUM.EQ.1) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.57
         GAMRX=0.9
         AMRB =AMKST
         GAMRB=GAMKST
         AMRA =AMRO
         GAMRA=GAMRO
      ELSEIF(MNUM.EQ.2) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.57
         GAMRX=0.9
         AMRB =AMKST
         GAMRB=GAMKST
         AMRA =AMRO
         GAMRA=GAMRO
      ELSEIF(MNUM.EQ.3) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.27
         GAMRX=0.3
         AMRA =AMKST
         GAMRA=GAMKST
         AMRB =AMKST
         GAMRB=GAMKST
      ELSEIF(MNUM.EQ.4) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.27
         GAMRX=0.3
         AMRA =AMKST
         GAMRA=GAMKST
         AMRB =AMKST
         GAMRB=GAMKST
      ELSEIF(MNUM.EQ.5) THEN
         PROB1=0.5
         PROB2=0.5
         AMRX =1.27
         GAMRX=0.3
         AMRA =AMKST
         GAMRA=GAMKST
         AMRB =AMRO
         GAMRB=GAMRO
      ELSEIF(MNUM.EQ.6) THEN
         PROB1=0.4
         PROB2=0.4
         AMRX =1.27
         GAMRX=0.3
         AMRA =AMRO
         GAMRA=GAMRO
         AMRB =AMKST
         GAMRB=GAMKST
      ELSEIF(MNUM.EQ.7) THEN
         PROB1=0.0
         PROB2=1.0
         AMRX =1.27
         GAMRX=0.9
         AMRA =AMRO
         GAMRA=GAMRO
         AMRB =AMRO
         GAMRB=GAMRO
      ELSEIF(MNUM.EQ.8) THEN
         PROB1=0.0
         PROB2=1.0
         AMRX =AMROP
         GAMRX=GAMROP
         AMRB =AMOM
         GAMRB=GAMOM
         AMRA =AMRO
         GAMRA=GAMRO
      ELSEIF(MNUM.EQ.101) THEN
         PROB1=.35
         PROB2=.35
         AMRX =1.2
         GAMRX=.46
         AMRB =AMOM
         GAMRB=GAMOM
         AMRA =AMOM
         GAMRA=GAMOM
      ELSEIF(MNUM.EQ.102) THEN
         PROB1=0.0
         PROB2=0.0
         AMRX =1.4
         GAMRX=.6
         AMRB =AMOM
         GAMRB=GAMOM
         AMRA =AMOM
         GAMRA=GAMOM
      ELSE
         PROB1=0.0
         PROB2=0.0
         AMRX =AMA1
         GAMRX=GAMA1
         AMRA =AMRO
         GAMRA=GAMRO
         AMRB =AMRO
         GAMRB=GAMRO
      ENDIF
*
      IF    (RR.LE.PROB1) THEN
         ICHAN=1
      ELSEIF(RR.LE.(PROB1+PROB2)) THEN
         ICHAN=2
         AX   =AMRA
         GX   =GAMRA
         AMRA =AMRB
         GAMRA=GAMRB
         AMRB =AX
         GAMRB=GX
         PX   =PROB1
         PROB1=PROB2
         PROB2=PX
      ELSE
         ICHAN=3
      ENDIF
*
      PROB3=1.0-PROB1-PROB2
      END


      SUBROUTINE INITDK
* ----------------------------------------------------------------------
*     INITIALISATION OF TAU DECAY PARAMETERS  and routines
*
*     called by : KORALZ
* ----------------------------------------------------------------------
      COMMON / DECPAR / GFERMI,GV,GA,CCABIB,SCABIB,GAMEL
      REAL*4            GFERMI,GV,GA,CCABIB,SCABIB,GAMEL
      COMMON / PARMAS / AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      REAL*4            AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
      COMMON / TAUBRA / GAMPRT(30),JLIST(30),NCHAN
      COMMON / TAUKLE / BRA1,BRK0,BRK0B,BRKS
      REAL*4            BRA1,BRK0,BRK0B,BRKS
      PARAMETER (NMODE=15,NM1=0,NM2=1,NM3=8,NM4=2,NM5=1,NM6=3)
      COMMON / DECOMP /IDFFIN(9,NMODE),MULPIK(NMODE)
     &                ,NAMES
      CHARACTER NAMES(NMODE)*31
      REAL*4 PI
*
* LIST OF BRANCHING RATIOS
*AM normalised to e nu nutau channel
*AM                  enu   munu   pinu  rhonu   A1nu   Knu    K*nu   pi'
*AM   DATA JLIST  /    1,     2,     3,     4,     5,     6,     7,
*AM   DATA GAMPRT /1.000,0.9730,0.6054,1.2432,0.8432,0.0432,O.O811,0.616
*AM
*AM  multipion decays
*
*    conventions of particles names
*                 K-,P-,K+,  K0,P-,KB,  K-,P0,K0
*                  3, 1,-3  , 4, 1,-4  , 3, 2, 4  ,
*                 P0,P0,K-,  K-,P-,P+,  P-,KB,P0
*                  2, 2, 3  , 3, 1,-1  , 1,-4, 2  ,
*                 ET,P-,P0   P-,P0,GM
*                  9, 1, 2  , 1, 2, 8
*
      DIMENSION NOPIK(6,NMODE),NPIK(NMODE)
*AM   outgoing multiplicity and flavors of multi-pion /multi-K modes    
      DATA   NPIK  /                4,                    4,  
     1                              5,                    5,
     2                              6,                    6,
     3                              3,                    3,            
     4                              3,                    3,            
     5                              3,                    3,            
     6                              3,                    3,  
     7                              2                         /         
      DATA  NOPIK / -1,-1, 1, 2, 0, 0,     2, 2, 2,-1, 0, 0,  
     1              -1,-1, 1, 2, 2, 0,    -1,-1,-1, 1, 1, 0,  
     2              -1,-1,-1, 1, 1, 2,    -1,-1, 1, 2, 2, 2, 
     3              -3,-1, 3, 0, 0, 0,    -4,-1, 4, 0, 0, 0,  
     4              -3, 2,-4, 0, 0, 0,     2, 2,-3, 0, 0, 0,  
     5              -3,-1, 1, 0, 0, 0,    -1, 4, 2, 0, 0, 0,  
     6               9,-1, 2, 0, 0, 0,    -1, 2, 8, 0, 0, 0,
     7              -3, 4, 0, 0, 0, 0                         /
* LIST OF BRANCHING RATIOS
      NCHAN = NMODE + 7
      DO 1 I = 1,30
      IF (I.LE.NCHAN) THEN
        JLIST(I) = I
        IF(I.EQ. 1) GAMPRT(I) = 1.0000
        IF(I.EQ. 2) GAMPRT(I) = 1.0000
        IF(I.EQ. 3) GAMPRT(I) = 1.0000
        IF(I.EQ. 4) GAMPRT(I) = 1.0000
        IF(I.EQ. 5) GAMPRT(I) = 1.0000
        IF(I.EQ. 6) GAMPRT(I) = 1.0000
        IF(I.EQ. 7) GAMPRT(I) = 1.0000
        IF(I.EQ. 8) GAMPRT(I) = 1.0000
        IF(I.EQ. 9) GAMPRT(I) = 1.0000
        IF(I.EQ.10) GAMPRT(I) = 1.0000
        IF(I.EQ.11) GAMPRT(I) = 1.0000
        IF(I.EQ.12) GAMPRT(I) = 1.0000
        IF(I.EQ.13) GAMPRT(I) = 1.0000
        IF(I.EQ.14) GAMPRT(I) = 1.0000
        IF(I.EQ.15) GAMPRT(I) = 1.0000
        IF(I.EQ.16) GAMPRT(I) = 1.0000
        IF(I.EQ.17) GAMPRT(I) = 1.0000
        IF(I.EQ.18) GAMPRT(I) = 1.0000
        IF(I.EQ.19) GAMPRT(I) = 1.0000
        IF(I.EQ.20) GAMPRT(I) = 1.0000
        IF(I.EQ.21) GAMPRT(I) = 1.0000
        IF(I.EQ.22) GAMPRT(I) = 1.0000
        IF(I.EQ. 8) NAMES(I-7)='  TAU-  --> 2PI-,  PI0,  PI+   '
        IF(I.EQ. 9) NAMES(I-7)='  TAU-  --> 3PI0,        PI-   '
        IF(I.EQ.10) NAMES(I-7)='  TAU-  --> 2PI-,  PI+, 2PI0   '
        IF(I.EQ.11) NAMES(I-7)='  TAU-  --> 3PI-, 2PI+,        '
        IF(I.EQ.12) NAMES(I-7)='  TAU-  --> 3PI-, 2PI+,  PI0   '
        IF(I.EQ.13) NAMES(I-7)='  TAU-  --> 2PI-,  PI+, 3PI0   '
        IF(I.EQ.14) NAMES(I-7)='  TAU-  -->  K-, PI-,  K+      '
        IF(I.EQ.15) NAMES(I-7)='  TAU-  -->  K0, PI-, K0B      '
        IF(I.EQ.16) NAMES(I-7)='  TAU-  -->  K-,  K0, PI0      '
        IF(I.EQ.17) NAMES(I-7)='  TAU-  --> PI0, PI0,  K-      '
        IF(I.EQ.18) NAMES(I-7)='  TAU-  -->  K-, PI-, PI+      '
        IF(I.EQ.19) NAMES(I-7)='  TAU-  --> PI-, K0B, PI0      '
        IF(I.EQ.20) NAMES(I-7)='  TAU-  --> ETA, PI-, PI0      '
        IF(I.EQ.21) NAMES(I-7)='  TAU-  --> PI-, PI0, GAM      '
        IF(I.EQ.22) NAMES(I-7)='  TAU-  -->  K-,  K0           '
      ELSE
        JLIST(I) = 0
        GAMPRT(I) = 0.
      ENDIF
   1  CONTINUE
      DO I=1,NMODE
        MULPIK(I)=NPIK(I)
        DO J=1,MULPIK(I)
         IDFFIN(J,I)=NOPIK(J,I)
        ENDDO
      ENDDO
*
*
* --- COEFFICIENTS TO FIX RATIO OF:
* --- A1 3CHARGED/ A1 1CHARGED 2 NEUTRALS MATRIX ELEMENTS (MASLESS LIM.)
* --- PROBABILITY OF K0 TO BE KS
* --- PROBABILITY OF K0B TO BE KS
* --- RATIO OF COEFFICIENTS FOR K*--> K0 PI-
* --- ALL COEFFICENTS SHOULD BE IN THE RANGE (0.0,1.0)
* --- THEY MEANING IS PROBABILITY OF THE FIRST CHOICE ONLY IF ONE
* --- NEGLECTS MASS-PHASE SPACE EFFECTS
      BRA1=0.5
      BRK0=0.5
      BRK0B=0.5
      BRKS=0.6667
*
* --- remaining constants
      PI =4.*ATAN(1.)
      GFERMI = 1.16637E-5
      CCABIB = 0.975
      GV     = 1.0
      GA     =-1.0
* ZW 13.04.89 HERE WAS AN ERROR
      SCABIB = SQRT(1.-CCABIB**2)
      GAMEL  = GFERMI**2*AMTAU**5/(192*PI**3)
*
*      CALL DEXAY(-1)
*
      RETURN
      END
      FUNCTION DCDMAS(IDENT)
      COMMON / PARMAS / AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      REAL*4            AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
      IF      (IDENT.EQ. 1) THEN
        APKMAS=AMPI
      ELSEIF  (IDENT.EQ.-1) THEN
        APKMAS=AMPI
      ELSEIF  (IDENT.EQ. 2) THEN
        APKMAS=AMPIZ
      ELSEIF  (IDENT.EQ.-2) THEN
        APKMAS=AMPIZ
      ELSEIF  (IDENT.EQ. 3) THEN
        APKMAS=AMK
      ELSEIF  (IDENT.EQ.-3) THEN
        APKMAS=AMK
      ELSEIF  (IDENT.EQ. 4) THEN
        APKMAS=AMKZ
      ELSEIF  (IDENT.EQ.-4) THEN
        APKMAS=AMKZ
      ELSEIF  (IDENT.EQ. 8) THEN
        APKMAS=0.0001
      ELSEIF  (IDENT.EQ.-8) THEN
        APKMAS=0.0001
      ELSEIF  (IDENT.EQ. 9) THEN
        APKMAS=0.5488
      ELSEIF  (IDENT.EQ.-9) THEN
        APKMAS=0.5488
      ELSE
        PRINT *, 'STOP IN APKMAS, WRONG IDENT=',IDENT
        STOP
      ENDIF
      DCDMAS=APKMAS
      END
      FUNCTION LUNPIK(ID,ISGN)
      COMMON / TAUKLE / BRA1,BRK0,BRK0B,BRKS
      REAL*4            BRA1,BRK0,BRK0B,BRKS
      IDENT=ID*ISGN
      IF      (IDENT.EQ. 1) THEN
        IPKDEF=-211
      ELSEIF  (IDENT.EQ.-1) THEN
        IPKDEF= 211
      ELSEIF  (IDENT.EQ. 2) THEN
        IPKDEF=111
      ELSEIF  (IDENT.EQ.-2) THEN
        IPKDEF=111
      ELSEIF  (IDENT.EQ. 3) THEN
        IPKDEF=-321
      ELSEIF  (IDENT.EQ.-3) THEN
        IPKDEF= 321
      ELSEIF  (IDENT.EQ. 4) THEN
*
* K0 --> K0_LONG (IS 130) / K0_SHORT (IS 310) = 1/1
        CALL RANMAR(XIO,1)
        IF (XIO.GT.BRK0) THEN
          IPKDEF= 130
        ELSE
          IPKDEF= 310
        ENDIF
      ELSEIF  (IDENT.EQ.-4) THEN
*
* K0B--> K0_LONG (IS 130) / K0_SHORT (IS 310) = 1/1
        CALL RANMAR(XIO,1)
        IF (XIO.GT.BRK0B) THEN
          IPKDEF= 130
        ELSE
          IPKDEF= 310
        ENDIF
      ELSEIF  (IDENT.EQ. 8) THEN
        IPKDEF= 22
      ELSEIF  (IDENT.EQ.-8) THEN
        IPKDEF= 22
      ELSEIF  (IDENT.EQ. 9) THEN
        IPKDEF= 221
      ELSEIF  (IDENT.EQ.-9) THEN
        IPKDEF= 221
      ELSE
        PRINT *, 'STOP IN IPKDEF, WRONG IDENT=',IDENT
        STOP
      ENDIF
      LUNPIK=IPKDEF
      END
      SUBROUTINE TAURDF(KTO)
* THIS ROUTINE CAN BE CALLED BEFORE ANY TAU+ OR TAU- EVENT IS GENERATED
* IT CAN BE USED TO GENERATE TAU+ AND TAU- SAMPLES OF DIFFERENT
* CONTENTS
      COMMON / TAUKLE / BRA1,BRK0,BRK0B,BRKS
      REAL*4            BRA1,BRK0,BRK0B,BRKS
      COMMON / TAUBRA / GAMPRT(30),JLIST(30),NCHAN
      IF (KTO.EQ.1) THEN
*     ==================
* LIST OF BRANCHING RATIOS
      NCHAN = 19
      DO 1 I = 1,30
      IF (I.LE.NCHAN) THEN
        JLIST(I) = I
        IF(I.EQ. 1) GAMPRT(I) = .0000
        IF(I.EQ. 2) GAMPRT(I) = .0000
        IF(I.EQ. 3) GAMPRT(I) = .0000
        IF(I.EQ. 4) GAMPRT(I) = .0000
        IF(I.EQ. 5) GAMPRT(I) = .0000
        IF(I.EQ. 6) GAMPRT(I) = .0000
        IF(I.EQ. 7) GAMPRT(I) = .0000
        IF(I.EQ. 8) GAMPRT(I) = 1.0000
        IF(I.EQ. 9) GAMPRT(I) = 1.0000
        IF(I.EQ.10) GAMPRT(I) = 1.0000
        IF(I.EQ.11) GAMPRT(I) = 1.0000
        IF(I.EQ.12) GAMPRT(I) = 1.0000
        IF(I.EQ.13) GAMPRT(I) = 1.0000
        IF(I.EQ.14) GAMPRT(I) = 1.0000
        IF(I.EQ.15) GAMPRT(I) = 1.0000
        IF(I.EQ.16) GAMPRT(I) = 1.0000
        IF(I.EQ.17) GAMPRT(I) = 1.0000
        IF(I.EQ.18) GAMPRT(I) = 1.0000
        IF(I.EQ.19) GAMPRT(I) = 1.0000
      ELSE
        JLIST(I) = 0
        GAMPRT(I) = 0.
      ENDIF
   1  CONTINUE
* --- COEFFICIENTS TO FIX RATIO OF:
* --- A1 3CHARGED/ A1 1CHARGED 2 NEUTRALS MATRIX ELEMENTS (MASLESS LIM.)
* --- PROBABILITY OF K0 TO BE KS
* --- PROBABILITY OF K0B TO BE KS
* --- RATIO OF COEFFICIENTS FOR K*--> K0 PI-
* --- ALL COEFFICENTS SHOULD BE IN THE RANGE (0.0,1.0)
* --- THEY MEANING IS PROBABILITY OF THE FIRST CHOICE ONLY IF ONE
* --- NEGLECTS MASS-PHASE SPACE EFFECTS
      BRA1=0.5
      BRK0=0.5
      BRK0B=0.5
      BRKS=0.6667
      ELSE
*     ====
* LIST OF BRANCHING RATIOS
      NCHAN = 19
      DO 2 I = 1,30
      IF (I.LE.NCHAN) THEN
        JLIST(I) = I
        IF(I.EQ. 1) GAMPRT(I) = .0000
        IF(I.EQ. 2) GAMPRT(I) = .0000
        IF(I.EQ. 3) GAMPRT(I) = .0000
        IF(I.EQ. 4) GAMPRT(I) = .0000
        IF(I.EQ. 5) GAMPRT(I) = .0000
        IF(I.EQ. 6) GAMPRT(I) = .0000
        IF(I.EQ. 7) GAMPRT(I) = .0000
        IF(I.EQ. 8) GAMPRT(I) = 1.0000
        IF(I.EQ. 9) GAMPRT(I) = 1.0000
        IF(I.EQ.10) GAMPRT(I) = 1.0000
        IF(I.EQ.11) GAMPRT(I) = 1.0000
        IF(I.EQ.12) GAMPRT(I) = 1.0000
        IF(I.EQ.13) GAMPRT(I) = 1.0000
        IF(I.EQ.14) GAMPRT(I) = 1.0000
        IF(I.EQ.15) GAMPRT(I) = 1.0000
        IF(I.EQ.16) GAMPRT(I) = 1.0000
        IF(I.EQ.17) GAMPRT(I) = 1.0000
        IF(I.EQ.18) GAMPRT(I) = 1.0000
        IF(I.EQ.19) GAMPRT(I) = 1.0000
      ELSE
        JLIST(I) = 0
        GAMPRT(I) = 0.
      ENDIF
   2  CONTINUE
* --- COEFFICIENTS TO FIX RATIO OF:
* --- A1 3CHARGED/ A1 1CHARGED 2 NEUTRALS MATRIX ELEMENTS (MASLESS LIM.)
* --- PROBABILITY OF K0 TO BE KS
* --- PROBABILITY OF K0B TO BE KS
* --- RATIO OF COEFFICIENTS FOR K*--> K0 PI-
* --- ALL COEFFICENTS SHOULD BE IN THE RANGE (0.0,1.0)
* --- THEY MEANING IS PROBABILITY OF THE FIRST CHOICE ONLY IF ONE
* --- NEGLECTS MASS-PHASE SPACE EFFECTS
      BRA1=0.5
      BRK0=0.5
      BRK0B=0.5
      BRKS=0.6667
      ENDIF
*     =====
      END

      SUBROUTINE INIPHY(XK00)
* ----------------------------------------------------------------------
*     INITIALISATION OF PARAMETERS
*     USED IN QED and/or GSW ROUTINES
* ----------------------------------------------------------------------
      COMMON / QEDPRM /ALFINV,ALFPI,XK0
      REAL*8           ALFINV,ALFPI,XK0
      REAL*8 PI8,XK00
*
      PI8    = 4.D0*DATAN(1.D0)
      ALFINV = 137.03604D0
      ALFPI  = 1D0/(ALFINV*PI8)
      XK0=XK00
      END

      SUBROUTINE INIMAS
* ----------------------------------------------------------------------
*     INITIALISATION OF MASSES
*
*     called by : KORALZ
* ----------------------------------------------------------------------
      COMMON / PARMAS / AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
*
      REAL*4            AMTAU,AMNUTA,AMEL,AMNUE,AMMU,AMNUMU
     *                 ,AMPIZ,AMPI,AMRO,GAMRO,AMA1,GAMA1
     *                 ,AMK,AMKZ,AMKST,GAMKST
      REAL*8 BornV_GetMass
*
* IN-COMING / OUT-GOING  FERMION MASSES
      AMTAU  = BornV_GetMass(15)
      AMNUTA = 0.010
      AMEL   = BornV_GetMass(11)
      AMNUE  = 0.0
      AMMU   = BornV_GetMass(13)
      AMNUMU = 0.0
*
* MASSES USED IN TAU DECAYS
      AMPIZ  = 0.134964
      AMPI   = 0.139568
      AMRO   = 0.773
      GAMRO  = 0.145
*C    GAMRO  = 0.666
      AMA1   = 1.251
      GAMA1  = 0.599
      AMK    = 0.493667
      AMKZ   = 0.49772
      AMKST  = 0.8921
      GAMKST = 0.0513
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//                          THE END of                                             //
*//   Standard Tauola interface/initialization routines of functionality exactly    //
*//   as in Tauola CPC                                                              //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      END

      SUBROUTINE TRALO4(KTO,P,Q,AM)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  SUBSITUTE OF TRALO4                                                            // 
*//  TRALO4 is called in TAUOLA /hepevt/ interface to boost from tau+-              //
*//  restframe to lab. It includes rotations in tau restframe due to spin effect    //
*//  implementation                                                                 //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      REAL  P(4),Q(4)
      REAL*8 PX(4),QX(4),thet1,phi1,thet2,phi2
*
      CALL RandomRotate(-kto,px,qx,thet1,phi1,thet2,phi2)
      DO k=1,4
         PX(K)=P(K)
      ENDDO
      AM=AMAS4(P)
c{{{{{
c      CALL rotod3(phi1,PX,QX)
c      CALL rotod1(thet1,QX,PX)
c}}}}}
      CALL rotod1(thet2,PX,qX)
      CALL rotod3(phi2,qX,PX)
      CALL  GPS_TralorDoIt(KTO,PX,QX)
      DO k=1,4
         Q(K)=QX(K)
      ENDDO
      END

      SUBROUTINE FILHEP(N,IST,ID,JMO1,JMO2,JDA1,JDA2,P4,PINV,PHFLAG)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  FILHEP of TAUOLA must be in single precission but double precision             // 
*//  HepEvt_Fil1 is its functional copy                                             //
*//  it consits of subroutines: PHOTOS_KK, PHOTOS_GET_KK, PHOTOS_SET_KK             //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
      LOGICAL PHFLAG
      REAL*8 PINVD,P4D(4)
      REAL P4(4)
      DO k=1,4
        P4D(k)=P4(k)
      ENDDO
      PINVD=PINV
      CALL HepEvt_Fil1(N,IST,ID,JMO1,JMO2,JDA1,JDA2,P4D,PINVD,PHFLAG)
      END

      SUBROUTINE PHOTOS_KK(ID)
*/////////////////////////////////////////////////////////////////////////////////////
*//                                                                                 //
*//  INTERFACE of PHOTOS for KORALZ-K. There /d_hepevt/ common block instead of     //
*//  /hepevt/ is used                                                               //
*//  it consits of subroutines: PHOTOS_KK, PHOTOS_GET_KK, PHOTOS_SET_KK             //
*//                                                                                 //
*/////////////////////////////////////////////////////////////////////////////////////
*----------------------------------------------------------------------
*
*    PHOTOS_KK:   PHOTOS for KK type of HEPEVT common  
*
*    Purpose:  /HEPEVT/ is not anymore a standard at least 
*              REAL*8 REAL*4 are in use now KORALZ has its own
*              REAL*8 version with the name /d_hepevt/
*
*    Input Parameters:   ID see routine Phot
*
*    Output Parameters:  None
*
*    Author(s):  Z. Was                          Created at:  21/07/98
*                                                Last Update: 21/07/98
*
*----------------------------------------------------------------------
      CALL PHOTOS_GET_KK
      CALL PHOTOS_MAKE(ID)
      CALL PHOTOS_SET_KK
      END

      SUBROUTINE  PHOTOS_GET_KK
*----------------------------------------------------------------------
*
*    Getter for PHOTOS_KK:   
*
*    Purpose:  Copies /D_HEPEVT/ into /PH_HEPEVT/
*              
*
*    Input Parameters:   None
*
*    Output Parameters:  None
*
*    Author(s):  Z. Was                          Created at:  21/07/98
*                                                Last Update: 21/07/98
*
*----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER  d_h_nmxhep         ! maximum number of particles
      PARAMETER ( d_h_nmxhep=2000)
      REAL*8  d_h_phep,  d_h_vhep
      INTEGER d_h_nevhep,d_h_nhep,d_h_isthep,d_h_idhep,d_h_jmohep,
     $        d_h_jdahep
      COMMON /d_hepevt/
     $      d_h_nevhep,               ! serial number
     $      d_h_nhep,                 ! number of particles
     $      d_h_isthep(d_h_nmxhep),   ! status code
     $      d_h_idhep(d_h_nmxhep),    ! particle ident KF
     $      d_h_jmohep(2,d_h_nmxhep), ! parent particles
     $      d_h_jdahep(2,d_h_nmxhep), ! childreen particles
     $      d_h_phep(5,d_h_nmxhep),   ! four-momentum, mass [GeV]
     $      d_h_vhep(4,d_h_nmxhep)    ! vertex [mm]
* ----------------------------------------------------------------------
*      LOGICAL d_h_qedrad
*      COMMON /phoqed/ 
*     $     d_h_qedrad(d_h_nmxhep)    ! Photos flag
      INTEGER NMXHEP
      PARAMETER (NMXHEP=2000)
      INTEGER IDHEP,ISTHEP,JDAHEP,JMOHEP,NEVHEP,NHEP
      REAL*8 PHEP,VHEP
      COMMON/PH_HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     &JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
      LOGICAL QEDRAD
      COMMON/PHOQED/QEDRAD(NMXHEP)
      integer k,l
         nevhep=  d_h_nevhep             ! serial number
         nhep  =  d_h_nhep               ! number of particles
         DO K=1,nhep
           isthep(k)    =d_h_isthep(k)   ! status code
           idhep(k)     =d_h_idhep(k)    ! particle ident KF
           jmohep(1,k)  =d_h_jmohep(1,k) ! parent particles
           jdahep(1,k)  =d_h_jdahep(1,k) ! childreen particles
           jmohep(2,k)  =d_h_jmohep(2,k) ! parent particles
           jdahep(2,k)  =d_h_jdahep(2,k) ! childreen particles
           DO l=1,4
           phep(l,k)    =d_h_phep(l,k)   ! four-momentum, mass [GeV]
           vhep(l,k)    =d_h_vhep(l,k)   ! vertex [mm]
           ENDDO
           phep(5,k)    =d_h_phep(5,k)   ! four-momentum, mass [GeV]
         ENDDO
      END


      SUBROUTINE PHOTOS_SET_KK
*----------------------------------------------------------------------
*
*    Setter for PHOTOS_KK:   
*
*    Purpose:  Copies /PH_HEPEVT/ into /D_HEPEVT/
*              
*
*    Input Parameters:   None
*
*    Output Parameters:  None
*
*    Author(s):  Z. Was                          Created at:  21/07/98
*                                                Last Update: 21/07/98
*
*----------------------------------------------------------------------
      IMPLICIT NONE
      INTEGER  d_h_nmxhep         ! maximum number of particles
      PARAMETER ( d_h_nmxhep=2000)
      REAL*8  d_h_phep,  d_h_vhep
      INTEGER d_h_nevhep,d_h_nhep,d_h_isthep,d_h_idhep,d_h_jmohep,
     $        d_h_jdahep
      COMMON /d_hepevt/
     $      d_h_nevhep,               ! serial number
     $      d_h_nhep,                 ! number of particles
     $      d_h_isthep(d_h_nmxhep),   ! status code
     $      d_h_idhep(d_h_nmxhep),    ! particle ident KF
     $      d_h_jmohep(2,d_h_nmxhep), ! parent particles
     $      d_h_jdahep(2,d_h_nmxhep), ! childreen particles
     $      d_h_phep(5,d_h_nmxhep),   ! four-momentum, mass [GeV]
     $      d_h_vhep(4,d_h_nmxhep)    ! vertex [mm]
* ----------------------------------------------------------------------
*      LOGICAL d_h_qedrad
*      COMMON /phoqed/ 
*     $     d_h_qedrad(d_h_nmxhep)    
      INTEGER NMXHEP
      PARAMETER (NMXHEP=2000)
      INTEGER IDHEP,ISTHEP,JDAHEP,JMOHEP,NEVHEP,NHEP
      REAL*8 PHEP,VHEP
      COMMON/PH_HEPEVT/NEVHEP,NHEP,ISTHEP(NMXHEP),IDHEP(NMXHEP),
     &JMOHEP(2,NMXHEP),JDAHEP(2,NMXHEP),PHEP(5,NMXHEP),VHEP(4,NMXHEP)
      LOGICAL QEDRAD
      COMMON/PHOQED/QEDRAD(NMXHEP)
      INTEGER K,L

      d_h_nevhep=  nevhep       ! serial number
      d_h_nhep  =  nhep         ! number of particles
      DO K=1,nhep
         d_h_isthep(k)    =isthep(k) ! status code
         d_h_idhep(k)     =idhep(k) ! particle ident KF
         d_h_jmohep(1,k)  =jmohep(1,k) ! parent particles
         d_h_jdahep(1,k)  =jdahep(1,k) ! childreen particles
         d_h_jmohep(2,k)  =jmohep(2,k) ! parent particles
         d_h_jdahep(2,k)  =jdahep(2,k) ! childreen particles
         DO l=1,4
            d_h_phep(l,k)    =phep(l,k) ! four-momentum, mass [GeV]
            d_h_vhep(l,k)    =vhep(l,k) ! vertex [mm]
         ENDDO
         d_h_phep(5,k)    =phep(5,k) ! four-momentum, mass [GeV]
      ENDDO
      END


